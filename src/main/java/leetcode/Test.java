package leetcode;

import org.apache.commons.lang.StringUtils;

import java.util.*;

/**
 * description
 *
 * @author cl10805
 * @date 2019/1/17 16:36
 */
public class Test {

    public static void main(String[] args) {
//        ListNode listNode = new ListNode(1);
//        listNode.next = new ListNode(2);
//        listNode.next.next = new ListNode(3);
//        System.out.println(reverseList(listNode));
//        countSubstrings("abc");
//        firstUniqChar("leetcode");
//        System.out.println(findAnagrams("aa", "bb"));

//        char[] array = reverse(" your code  \0 this is extra".toCharArray());
//        System.out.println(Arrays.toString(array));

//        int[][] nums = new int[][]{new int[]{2, 3, 4}, new int[]{5, 6, 7}, new int[]{8, 9, 10}, new int[]{11, 12, 13}, new int[]{14, 15, 16}};
//        int[][] rsp = imageSmoother(nums);
//        int[] nums = new int[]{1, 2, 2, 3, 1};
//        System.out.println(findShortestSubArray(nums));
//        String s = StringUtils.strip("");
//        int[] nums = new int[]{1, 1, 1, 2, 2, 2, 3, 3};
//        System.out.println(hasGroupsSizeX(nums));
//        ListNode listNode = new ListNode(1);
//        listNode.next = new ListNode(1);
//        listNode.next.next = new ListNode(2);
//        listNode.next.next.next = new ListNode(3);
//        listNode.next.next.next.next = new ListNode(4);
//        listNode.next.next.next.next.next = new ListNode(4);
//        listNode.next.next.next.next.next.next = new ListNode(5);
//        deleteDuplicates(listNode);
        //System.out.println(Integer.valueOf(String.valueOf('1')));
//        System.out.println((int) '`');
//        System.out.println((int) 'A');
//        System.out.println((int) 'a');
//        isPalindrome("`l;`` 1o1 ??;l`");
//        convertToTitle(1);
//        System.out.println(trailingZeroes(5));
//        System.out.println("a".compareTo("2"));
//        trailingZeroes(30);
//        reverseWords("a good   example");
//        int[] array = new int[]{1, 3, 1, 3, 100};
//        System.out.println(rob(array));

//        String s = Integer.toString(10, 2);
//        System.out.println(s);
//        char[] array = new char[]{'a', 'b', 'c'};
//        System.out.println(compress(array));
//        System.out.println(countSegments("Hello, my name is John"));
//        int[] nums = new int[]{83, 86, 77, 15, 93, 35, 86, 92, 49, 21};
//        minMoves(nums);
//        String s = "aba";
//        System.out.println(repeatedSubstringPattern(s));
//        System.out.println(5^4);
//        System.out.println(hammingDistance(4, 1));
//        strStr("a", "a");
//        System.out.println(countAndSay(5));
//        int[][] array = new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
//        rotate(array);
//        String[] array = new String[]{"anagram", "nagaram"};
//        System.out.println(groupAnagrams(array));
//        System.out.println(lengthOfLastWord("hello world   "));
//        System.out.println(generateMatrix(3));
//        System.out.println(getPermutation(9, 54494));
//        System.out.println(simplifyPath("/a/./b/../../c/"));
//        int[][] array = new int[][]{{1, 1, 1}, {1, 0, 1}, {1, 1, 1}};
//        setZeroes(array);
//        int[] nums = new int[]{2, 0, 1};
//        sortColors(nums);

//        int[] nums = new int[]{6, 5, 4, 3, 2, 1};
//        quickSort(nums, 0, nums.length - 1);

//        char[][] array = new char[][]{{'a', 'b', 'c', 'e'}, {'s', 'f', 'e', 's'}, {'a', 'd', 'e', 'e'}};
//        System.out.println(exist(array, "abceseeefs"));
//        int[] array = new int[]{0, 0, 1, 1, 1, 1, 2, 3, 3};
//        removeDuplicates(array);
//        int[] array = new int[]{3, 1};
//        search2(array, 1);
//        System.out.println(numDecodings("00"));
//        ListNode listNode = new ListNode(1);
//        listNode.next = new ListNode(2);
//        listNode.next.next = new ListNode(3);
//        listNode.next.next.next = new ListNode(4);
//        listNode.next.next.next.next = new ListNode(5);
//        reverseBetween(listNode, 2, 4);
//        List<List<Integer>> triangle = new ArrayList<>();
//        List<Integer> temp1 = new ArrayList<>();
//        temp1.add(2);
//        triangle.add(temp1);
//        List<Integer> temp2 = new ArrayList<>();
//        temp2.add(3);
//        temp2.add(4);
//        triangle.add(temp2);
//        List<Integer> temp3 = new ArrayList<>();
//        temp3.add(6);
//        temp3.add(5);
//        temp3.add(7);
//        triangle.add(temp3);
//        List<Integer> temp4 = new ArrayList<>();
//        temp4.add(4);
//        temp4.add(1);
//        temp4.add(8);
//        temp4.add(3);
//        triangle.add(temp4);
//        minimumTotal(triangle);
//        List<String> list = new ArrayList<>();
//        list.add("hot");
//        list.add("dot");
//        list.add("dog");
//        list.add("lot");
//        list.add("log");
//        list.add("cog");
//        ladderLength("hit", "cog", list);
//        String test = "123||345||456||";
//        System.out.println(test.substring(1));
//        System.out.println(partition("aab"));
//        int[] test = new int[]{1, 2, 2, 2, 1, 1, 3};
//        System.out.println(singleNumber(test));
//        System.out.println(fractionToDecimal(20, 7));

//        System.out.println(hammingWeight(3));
//        System.out.println(minSubArrayLen(7, new int[]{2, 3, 1, 2, 4, 3}));
//
//        String[] fields = StringUtils.split("^tab选中：国内酒店^是否有经纬度进行周边搜索:是^街道地址:工业园区^当前城市:苏州^当前城市id:1102^商圈id:^商圈类型id:^入店日期:2019-05-20^离店日期:2019-05-21^关键词:^价格:[]^星级:[]", "^");
//        System.out.println(fields[6]);
//        System.out.println(Integer.MAX_VALUE+2);
//        System.out.println(Integer.MIN_VALUE-1);
//          maximalSquare(new char[][] {
//              {'1','1','1'},
//              {'1','0','1'},
//              {'1','1','1'}
//          });
//        System.out.println(calculate(" 3+2*2 "));
//        int[] nums = new int[]{0,2,3,4,6,8,9};
//        System.out.println(summaryRanges(nums));
//        System.out.println(countDigitOne(13));
//        ListNode listNode = new ListNode(1);
//        listNode.next = new ListNode(2);
//        listNode.next.next = new ListNode(3);
//        listNode.next.next.next = new ListNode(4);
//        listNode.next.next.next.next = new ListNode(5);
//        System.out.println(oddEvenList((listNode)));
//        nthUglyNumber(2);
//        int[] array = new int[]{0, 0,4,4};
//        hIndex2(array);
//        firstBadVersion(2126753390);
        String s = "Let's  join bytedance  ";
//        String[] array = StringUtils.split(s);
//        String[] array = s.split(" ");
        System.out.println(reverseWords(s));
    }

    public static String reverseWords(String s){
        String[] strArr = s.split(" ");
        int len = strArr.length;
        StringBuilder sb = new StringBuilder();
        for (int i = len -1; i >= 0; i--) {
            if (strArr[i].equals("")) {
                sb.append(" ");
            } else {
                sb.append(strArr[i]);
            }
        }
        return sb.toString();
    }

    /**
     * leetcode 278 第一个错误版本
     * @param n
     * @return
     */
    public static int firstBadVersion(int n) {
        //典型的二分查找
        int l=1, r= n;
        while(l<r){
            int mid = (int)((long)l+r)>>1;
            if(isBadVersion(mid)){
                r = mid;
            }else{
                l = mid+1;
            }
        }
        return l;
    }

    private static boolean isBadVersion(int n){
        return n >= 1702766719;
    }

    /**
     * H指数 leetcode 275
     * @param citations
     * @return
     */
    public static int hIndex2(int[] citations) {
        //看到对数就想到二分
        int l = 0, r = citations.length-1;
        if (citations.length == 0 || citations[citations.length - 1] == 0) {
            return 0;
        }
        while(l < r){
            int mid = (l + r)>>1;
            int h = citations.length - mid;
            if(h > citations[mid]){
                l = mid + 1;
            }else{
                r = mid;
            }
        }
        return citations.length-l;
    }

    /**
     * H指数 leetcode 274
     * @param citations
     * @return
     */
    public static int hIndex(int[] citations) {
        if(citations==null || citations.length==0)
            return 0;
        Arrays.sort(citations);
        int res=0, count =1;
        TreeMap<Integer,Integer> map= new TreeMap<>();
        for(int i= citations.length-1; i>=0; i--){
            if(map.containsKey(citations[i])){
                map.put(citations[i], map.get(citations[i])+1);
            }else{
                map.put(citations[i], count);
            }
            count++;
        }
        for(int key: map.keySet()){
            if(key>=map.get(key)) {
                res = map.get(key);
                break;
            }
        }
        if(map.lastKey()<map.get(map.lastKey())){
            res=map.lastKey();
        }
        return res;
    }

    /**
     * 丑数2  leetcode 264
     * @param n
     * @return
     */
    public static int nthUglyNumber(int n) {
        //java三指针
        int[] res= new int[n];
        res[0] = 1;
        int idx2=0, idx3=0, idx5=0;
        for(int i=1; i<n; i++){
            res[i] = Math.min(res[idx2], Math.min(res[idx3], res[idx5]));
            if(res[i]==res[idx2]*2)
                idx2++;
            if(res[i]==res[idx3]*3)
                idx3++;
            if(res[i]==res[idx5]*5)
                idx5++;
        }
        return res[n-1];
    }

    /**
     * 241 为运算表达式设计优先级
     * @param input
     * @return
     */
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> rsp = new ArrayList<>();
        return null;
    }

    /**
     * 240. 搜索二维矩阵 II
     *
     * @param matrix
     * @param target
     * @return
     */
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0) {
            return false;
        }
        int i = 0, j = matrix[0].length;
        while (i < matrix.length && j >= 0) {
            if (matrix[i][j] == target) {
                return true;
            } else if (matrix[i][j] > target) {
                j--;
            } else {
                i++;
            }
        }
        return false;
    }

    /**
     * Returns a random node's value. leetcode 382
     */
    public int getRandom(ListNode head) {
        return 0;
    }

    /**
     * 奇偶链表 leetcode 328
     *
     * @param head
     * @return
     */
    public static ListNode oddEvenList(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode oddList = head;
        ListNode evenList = head.next;
        ListNode evenHead = evenList;
        while (oddList != null && evenList != null && evenList.next != null) {
            oddList.next = evenList.next;
            evenList.next = evenList.next.next;
            oddList = oddList.next;
            evenList = evenList.next;
        }
        oddList.next = evenHead;
        return head;
    }

    /**
     * 数字1的个数，计算所有小于n的非负整数中出现1的个数
     *
     * @param n
     * @return
     */
    public static int countDigitOne(int n) {
        int rsp = 0;
        if (n < 1) {
            return rsp;
        }
        int begin = 1;
        while (begin <= n) {
            int num = begin;
            while (num > 0) {
                if ((num % 10) == 1) {
                    rsp++;
                }
                num /= 10;
            }
            begin++;
        }
        return rsp;
    }

    /**
     * 求出出现次数大于N/3的数字  摩尔投票法 leetcode 229
     *
     * @param nums
     * @return
     */
    public List<Integer> majorityElement2(int[] nums) {
        List<Integer> rsp = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return rsp;
        }
        int x = 0, y = 0, cx = 0, cy = 0;
        for (int num : nums) {
            if ((cx == 0 || x == num) && num != y) {
                x = num;
                cx++;
            } else if (cy == 0 || y == num) {
                y = num;
                cy++;
            } else {
                cx--;
                cy--;
            }
        }
        cx = 0;
        cy = 0;
        for (int temp : nums) {
            if (x == temp) {
                cx++;
            } else if (y == temp) {
                cy++;
            }
        }
        if (cx > nums.length / 3) {
            rsp.add(x);
        }
        if (cy > nums.length / 3) {
            rsp.add(y);
        }
        return rsp;
    }

    /**
     * 汇总区间
     *
     * @param nums
     * @return
     */
    public static List<String> summaryRanges(int[] nums) {
        List<String> rsp = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return rsp;
        }
        if (nums.length == 1) {
            rsp.add(String.valueOf(nums[0]));
            return rsp;
        }
        int begin = nums[0];
        int end = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == end + 1) {
                end = nums[i];
                if (i == nums.length - 1) {
                    rsp.add(begin + "->" + end);
                }
            } else {
                if (begin == end) {
                    rsp.add(String.valueOf(begin));
                } else {
                    rsp.add(begin + "->" + end);
                }
                begin = nums[i];
                end = nums[i];
                if (i == nums.length - 1) {
                    rsp.add(String.valueOf(begin));
                }
            }
        }
        return rsp;
    }

    /**
     * int res = 0, d = 0;
     * char sign = '+';
     * stack<int> nums;
     * for (int i = 0; i < s.size(); ++i) {
     * if (s[i] >= '0') {//加减乘除和空格ASCII码都小于'0'
     * d = d * 10 - '0' + s[i];//进位(先减法)
     * }
     * if ((s[i] < '0' && s[i] != ' ') || i == s.size() - 1) {
     * if (sign == '+') {
     * nums.push(d);
     * } else if (sign == '-') {
     * nums.push(-d);
     * } else if (sign == '*' || sign == '/') {
     * int tmp = sign == '*' ? nums.top() * d : nums.top() / d;
     * nums.pop();
     * nums.push(tmp);
     * }
     * sign = s[i]; //保存当前符号
     * d = 0;
     * }
     * }
     * for (; !nums.empty(); nums.pop()) {
     * res += nums.top();
     * }
     * return res;
     *
     * @param s
     * @return
     */
    public static int calculate(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int num = 0;
        char sign = '+';
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c >= '0') {
                num = num * 10 + c - '0';
            }
            //在碰到下一个符号、或者最后一位时，数字才停止，并与上一个符号进行运算
            if ((c < '0' && c != ' ') || i == s.length() - 1) {
                if (sign == '+') {
                    stack.push(num);
                } else if (sign == '-') {
                    stack.push(-num);
                } else {
                    stack.push(sign == '*' ? num * stack.pop() : stack.pop() / num);
                }
                sign = c;
                num = 0;
            }
        }
        int rsp = 0;
        while (!stack.isEmpty()) {
            rsp += stack.pop();
        }
        return rsp;
    }

    /**
     * leetcode 221 矩阵最大正方形
     *
     * @param matrix
     * @return
     */
    private static int maximalSquare(char[][] matrix) {
        /**
         dp[i][j]表示以第i行第j列为右下角所能构成的最大正方形边长, 则递推式为:
         dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);
         **/
        int m = matrix.length;
        if (m < 1) return 0;
        int n = matrix[0].length;
        int max = 0;
        int[][] dp = new int[m + 1][n + 1];

        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (matrix[i - 1][j - 1] == '1') {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1]));
                    max = Math.max(max, dp[i][j]);
                }
            }
        }

        return max * max;
    }

    // Get the ID of the bucket from element value x and bucket width w
    // In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.
    //原因在于，正数情况下，会有0-t的数字在桶0里，负数也会有类似的情况，所以要把负数的桶-1
    private long getID(long x, long w) {
        return x < 0 ? (x + 1) / w - 1 : x / w;
    }

    /**
     * leetCode 220 存在重复元素 III
     *
     * @param nums
     * @param k
     * @param t
     * @return
     */
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (t < 0) return false;
        Map<Long, Long> d = new HashMap<>();
        long w = (long) t + 1;
        for (int i = 0; i < nums.length; ++i) {
            long m = getID(nums[i], w);
            // check if bucket m is empty, each bucket may contain at most one element
            if (d.containsKey(m))
                return true;
            // check the nei***or buckets for almost duplicate
            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)
                return true;
            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)
                return true;
            // now bucket m is empty and no almost duplicate in nei***or buckets
            d.put(m, (long) nums[i]);
            if (i >= k) d.remove(getID(nums[i - k], w));
        }
        return false;
    }


    /**
     * 合并区间
     *
     * @param intervals
     * @return
     */
    public List<Interval> merge(List<Interval> intervals) {
        if (intervals == null || intervals.size() < 2) {
            return intervals;
        }
        List<Interval> rsp = new ArrayList<>();
        Interval pre = intervals.get(0);
        for (int i = 1; i < intervals.size(); i++) {
            Interval interval = intervals.get(i);
            if (interval.start <= pre.end && interval.end >= pre.end) {
                pre = new Interval(pre.start, interval.end);
                rsp.add(pre);
            }
        }
        return rsp;
    }

    private static class Interval {
        int start;
        int end;

        Interval() {
            start = 0;
            end = 0;
        }

        Interval(int s, int e) {
            start = s;
            end = e;
        }
    }

    /**
     * 在有序数组中，找到指定元素，如果没有，则返回插入的位置
     *
     * @param nums
     * @param target
     * @return
     */
    public int searchInsert(int[] nums, int target) {
        // if(nums==null||nums.length==0){
        //     return 0;
        // }
        // int i=0;
        // while(i<nums.length){
        //     if(nums[i]>=target){
        //         return i;
        //     }
        //     i++;
        // }
        // return i;

        //用二分查找试试
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (right < 0) {
            return 0;
        }
        return nums[right] >= target ? right : right + 1;
    }

    /**
     * 查找排序数组中 指定元素的起始位和结束位  二分查找
     *
     * @param nums
     * @param target
     * @return
     */
    public int[] searchRange(int[] nums, int target) {
        if (nums == null || nums.length == 0 || target < nums[0] || target > nums[nums.length - 1]) {
            return new int[]{-1, -1};
        }
        int[] res = new int[2];
        res[0] = findFirst(nums, target);
        res[1] = findLast(nums, target);
        return res;
    }

    private int findFirst(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (left < nums.length && nums[left] == target) {
            return left;
        } else {
            return -1;
        }
    }

    private int findLast(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (right > 0 && nums[right] == target) {
            return right;
        } else {
            return -1;
        }
    }

    /**
     * 获取所有可能的括号组合
     *
     * @param n
     * @return
     */
    public List<String> generateParenthesis(int n) {
        List<String> rsp = new ArrayList<>();
        if (n < 1) {
            return rsp;
        }
        int left = n, right = n;
        generateDfs(rsp, left, right, "");
        return rsp;
    }

    private void generateDfs(List<String> list, int left, int right, String temp) {
        if (left == 0 && right == 0) {
            list.add(temp);
        } else {
            if (left > 0) {
                generateDfs(list, left - 1, right, temp + "(");
            }
            if (right > left) {
                generateDfs(list, left, right - 1, temp + ")");
            }
        }
    }

    /**
     * 电话号码对应的字母组合
     *
     * @param digits
     * @return
     */
    public List<String> letterCombinations(String digits) {
        List<String> letterCombineList = new ArrayList<>();
        String[] s = new String[digits.length()];
        if (s.length == 0) {
            return letterCombineList;
        }
        for (int i = 0; i < digits.length(); i++) {
            switch (digits.charAt(i)) {
                case '2':
                    s[i] = "abc";
                    break;
                case '3':
                    s[i] = "def";
                    break;
                case '4':
                    s[i] = "ghi";
                    break;
                case '5':
                    s[i] = "jkl";
                    break;
                case '6':
                    s[i] = "mno";
                    break;
                case '7':
                    s[i] = "pqrs";
                    break;
                case '8':
                    s[i] = "tuv";
                    break;
                case '9':
                    s[i] = "wxyz";
                    break;
                default:
                    break;
            }
        }
        getStringWithFor(s, letterCombineList, "", 0);
        return letterCombineList;
    }

    private void getStringWithFor(String[] s, List<String> list, String stemp, int k) {
        if (k == s.length) {
            list.add(stemp);
        } else {
            for (int i = 0; i < s[k].length(); i++) {
                getStringWithFor(s, list, stemp + s[k].charAt(i), k + 1);
            }
        }
    }

    /**
     * 长度最小的子数组
     *
     * @param s
     * @param nums
     * @return
     */
    public static int minSubArrayLen(int s, int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int l = 0;
        int r = -1;
        int res = Integer.MAX_VALUE;
        int sum = 0;
        while (l < nums.length) {
            if (r + 1 < nums.length && sum < s) {
                r++;
                sum += nums[r];
            } else {
                sum -= nums[l];
                l++;
            }
            if (sum >= s) {
                res = Math.min(res, r - l + 1);
            }
        }
        return res == Integer.MAX_VALUE ? 0 : res;
    }

    /**
     * 汉明重量（二进制中1的个数）
     *
     * @param n
     * @return
     */
    public static int hammingWeight(int n) {
        int i = 32, rsp = 0;
        while (i > 0) {
            rsp += n & 1;
            n >>= 1;
            i--;
        }
        return rsp;
    }

    /**
     * 求众数
     *
     * @param nums nums不为空且一定存在众数，众数数量大于总数的一般
     * @return
     */
    public int majorityElement(int[] nums) {
        int ret = nums[0], count = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == ret) {
                count++;
            } else {
                if (count == 0) {
                    ret = nums[i];
                    count = 1;
                } else {
                    count--;
                }

            }
        }
        return ret;
    }

    /**
     * 两数之和 返回两数的索引
     *
     * @param numbers
     * @param target
     * @return
     */
    public int[] twoSum(int[] numbers, int target) {
        if (numbers == null || numbers.length < 2) {
            return null;
        }
        int i = 0, j = numbers.length - 1;
        while (i < j) {
            int temp = numbers[i] + numbers[j];
            if (temp < target) {
                while (i < j && numbers[i] == numbers[i + 1]) {
                    i++;
                }
                i++;
            } else if (temp > target) {
                while (j > i && numbers[j] == numbers[j - 1]) {
                    j--;
                }
                j--;
            } else {
                return new int[]{++i, ++j};
            }
        }
        return null;
    }

    /**
     * 分数到小数 重复的部分放在小括号里
     *
     * @param numerator
     * @param denominator
     * @return
     */
    public static String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) {
            return "0";
        }
        String sig = (numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0) ? "-" : "";
        StringBuilder res = new StringBuilder();
        res.append(sig);
        long num = Math.abs((long) numerator);
        long de = Math.abs((long) denominator);
        res.append(num / de);
        long remainder = num % de;
        if (remainder > 0) {
            res.append(".");
            HashMap<Long, Integer> map = new HashMap<>();
            while (!map.containsKey(remainder)) {
                map.put(remainder, res.length());
                res.append(remainder * 10 / de);
                remainder = remainder * 10 % de;
            }
            res.insert(map.get(remainder), "(");
            res.append(")");
        }
        return res.toString().replace("(0)", "");
    }

    /**
     * 相交链表
     *
     * @param headA
     * @param headB
     * @return
     */
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
//        if (headA == headB) {
//            return headA;
//        }
//        /**
//         定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)
//         两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度
//         **/
//        if (headA == null || headB == null) {
//            return null;
//        }
//        ListNode pA = headA, pB = headB;
//        // 在这里第一轮体现在pA和pB第一次到达尾部会移向另一链表的表头, 而第二轮体现在如果pA或pB相交就返回交点, 不相交最后就是null==null
//        while (pA != pB) {
//            pA = pA == null ? headB : pA.next;
//            pB = pB == null ? headA : pB.next;
//        }
//        return pA;

        // 解法2 将链表变为有环链表，找出环的入口
        if (headA == null || headB == null) {
            return null;
        }
        ListNode last = headB;
        while (last.next != null) {
            last = last.next;
        }
        last.next = headB;//变为有环

        ListNode fast = headA;
        ListNode slow = headA;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow == fast) {
                slow = headA;
                while (slow != fast) {
                    slow = slow.next;
                    fast = fast.next;
                }
                last.next = null;
                return fast;
            }
        }
        last.next = null;
        return null;
    }

    /**
     * 旋转数组中找到最小的(二分法)
     *
     * @param nums
     * @return
     */
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return nums[left];
    }

    /**
     * 乘积最大子序列
     *
     * @param nums
     * @return
     */
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < 0) {
                int temp = imax;
                imax = imin;
                imin = temp;
            }
            imax = Math.max(imax * nums[i], nums[i]);
            imin = Math.min(imin * nums[i], nums[i]);
            max = Math.max(max, imax);
        }
        return max;
    }

    /**
     * 参考：Sort List——经典（链表中的归并排序） https://www.cnblogs.com/qiaozhoulin/p/4585401.html
     * <p>
     * 归并排序法：在动手之前一直觉得空间复杂度为常量不太可能，因为原来使用归并时，都是 O(N)的，
     * 需要复制出相等的空间来进行赋值归并。对于链表，实际上是可以实现常数空间占用的（链表的归并
     * 排序不需要额外的空间）。利用归并的思想，递归地将当前链表分为两段，然后merge，分两段的方
     * 法是使用 fast-slow 法，用两个指针，一个每次走两步，一个走一步，知道快的走到了末尾，然后
     * 慢的所在位置就是中间位置，这样就分成了两段。merge时，把两段头部节点值比较，用一个 p 指向
     * 较小的，且记录第一个节点，然后 两段的头一步一步向后走，p也一直向后走，总是指向较小节点，
     * 直至其中一个头为NULL，处理剩下的元素。最后返回记录的头即可。
     * <p>
     * 主要考察3个知识点，
     * 知识点1：归并排序的整体思想
     * 知识点2：找到一个链表的中间节点的方法
     * 知识点3：合并两个已排好序的链表为一个新的有序链表
     */
    public ListNode sortList(ListNode head) {
        return head == null ? null : mergeSort(head);
    }

    private ListNode mergeSort(ListNode head) {
        if (head.next == null) {
            return head;
        }
        ListNode p = head, q = head, pre = null;
        while (q != null && q.next != null) {
            pre = p;
            p = p.next;
            q = q.next.next;
        }
        pre.next = null;
        ListNode l = mergeSort(head);
        ListNode r = mergeSort(p);
        return merge(l, r);
    }

    ListNode merge(ListNode l, ListNode r) {
        ListNode dummyHead = new ListNode(0);
        ListNode cur = dummyHead;
        while (l != null && r != null) {
            if (l.val <= r.val) {
                cur.next = l;
                cur = cur.next;
                l = l.next;
            } else {
                cur.next = r;
                cur = cur.next;
                r = r.next;
            }
        }
        if (l != null) {
            cur.next = l;
        }
        if (r != null) {
            cur.next = r;
        }
        return dummyHead.next;
    }


    /**
     * 插入链表排序
     *
     * @param head
     * @return
     */
    public ListNode insertionSortList(ListNode head) {
        if (head == null) {
            return head;
        }
        //begin是当前节点的前一节点
        ListNode cur = head.next, begin = head, dummyHead = new ListNode(-1);
        dummyHead.next = head;
        while (cur != null) {
            ListNode nextTemp = cur.next;
            //本就有序
            if (begin.val <= cur.val) {
                begin = cur;
                cur = nextTemp;
                continue;
            }
            ListNode pre = dummyHead;
            //寻找插入位置
            while (pre.next != null && pre != begin && pre.next.val < cur.val) {
                pre = pre.next;
            }
            //如果插入位置就是自己，则不用插入
            if (pre.next != cur) {
                //将节点放入链表指定位置
                cur.next = pre.next;
                pre.next = cur;
            }
            begin.next = nextTemp;
            cur = nextTemp;
        }
        return dummyHead.next;
    }

    /**
     * 返回链表入环的一个节点
     *
     * @param head
     * @return
     */
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }
        ListNode p = head, p2 = head;
        boolean hasCyc = false;
        while (p2 != null && p2.next != null) {
            p = p.next;
            p2 = p2.next.next;
            if (p == p2) {
                hasCyc = true;
                break;
            }
        }
        if (hasCyc) {
            ListNode q = head;
            while (q != p) {
                q = q.next;
                p = p.next;
            }
            return p;
        } else {
            return null;
        }

    }

    /**
     * 只出现一次的数字(除了唯一数字外，其他数字都出现3次)
     *
     * @param nums
     * @return
     */
    public static int singleNumber(int[] nums) {
//        int a = 0, b = 0;
//        for (int x : nums) {
//            b = (b ^ x) & ~a;
//            a = (a ^ x) & ~b;
//        }
//        return b;
        int one = 0, two = 0, three;
        for (int num : nums) {
            // two的相应的位等于1，表示该位出现2次
            two |= (one & num);
            // one的相应的位等于1，表示该位出现1次
            one ^= num;
            // three的相应的位等于1，表示该位出现3次
            three = (one & two);
            // 如果相应的位出现3次，则该位重置为0
            two &= ~three;
            one &= ~three;
        }
        return one;
    }

    /**
     * @param s
     * @return
     */
    public static List<List<String>> partition(String s) {
        List<List<String>> rsp = new ArrayList<>();
        getPla(rsp, new ArrayList<String>(), s);
        return rsp;
    }

    private static void getPla(List<List<String>> rsp, List<String> temp, String left) {
        if (left.length() == 0) {
            if (temp.size() > 0) {
                rsp.add(new ArrayList<String>(temp));
            }
        } else {
            for (int i = 1; i <= left.length(); i++) {
                String s = left.substring(0, i);
                if (isSymmetry(s)) {
                    temp.add(s);
                    getPla(rsp, temp, left.substring(i));
                    temp.remove(temp.size() - 1);
                }
            }
        }
    }

    private static boolean isSymmetry(String str) {
        if (str == null || str.length() == 0) {
            return false;
        }
        int i = 0, j = str.length() - 1;
        while (i < j) {
            if (str.charAt(i) != str.charAt(j)) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }

    /**
     * 被围绕的区域
     * 思路：将边缘连接的点全部置为新符号-，然后将所有O置为X，再将-置为O
     *
     * @param board
     */
    int row, col;

    public void solve(char[][] board) {
        if (board == null || board.length == 0)
            return;
        row = board.length;
        col = board[0].length;
        for (int i = 0; i < row; i++) {
            dfs(board, i, 0);
            dfs(board, i, col - 1);
        }
        for (int j = 0; j < col; j++) {
            dfs(board, 0, j);
            dfs(board, row - 1, j);
        }
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (board[i][j] == 'O')
                    board[i][j] = 'X';
                if (board[i][j] == '-')
                    board[i][j] = 'O';
            }
        }
        return;
    }

    public void dfs(char[][] board, int i, int j) {
        if (i < 0 || j < 0 || i >= row || j >= col || board[i][j] != 'O') {
            return;
        }
        board[i][j] = '-';
        dfs(board, i - 1, j);
        dfs(board, i + 1, j);
        dfs(board, i, j - 1);
        dfs(board, i, j + 1);
    }

    /**
     * 单词接龙
     *
     * @param beginWord
     * @param endWord
     * @param wordList
     * @return
     */
    public static int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> wordlist = new LinkedHashSet<>(wordList);
        if (!wordlist.contains(endWord)) {
            return 0;
        }
        if (wordlist.contains(beginWord)) {
            wordlist.remove(beginWord);
        }
        int res = 2;

        Set<String> forward = new LinkedHashSet<>();
        forward.add(beginWord);
        Set<String> backward = new LinkedHashSet<>();
        backward.add(endWord);
        String zm = "qwertyuioplkjhgfdsazxcvbnm";
        char[] letters = zm.toCharArray();
        int length = endWord.length();
        Set<String> temp = null;
        String x, y, z;
        while (forward.size() != 0) {
            if (forward.size() > backward.size()) {
                temp = forward;
                forward = backward;
                backward = temp;
            }
            temp = new LinkedHashSet<>();
            for (String word : forward) {
                for (int i = 0; i < length; i++) {
                    x = word.substring(0, i);
                    y = word.substring(i + 1);
                    for (char c : letters) {
                        z = x + c + y;
                        if (backward.contains(z)) {
                            return res;
                        }
                        if (wordlist.contains(z)) {
                            temp.add(z);
                            wordlist.remove(z);
                        }
                    }
                }

            }
            res++;
            forward = temp;
        }
        return 0;
    }

    /**
     * 三角形最小路径和
     *
     * @param triangle
     * @return
     */
    public static int minimumTotal(List<List<Integer>> triangle) {
        if (triangle == null || triangle.size() == 0) {
            return 0;
        }
        // 加1可以不用初始化最后一层
        int[][] dp = new int[triangle.size() + 1][triangle.size() + 1];

        for (int i = triangle.size() - 1; i >= 0; i--) {
            List<Integer> curTr = triangle.get(i);
            for (int j = 0; j < curTr.size(); j++) {
                dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + curTr.get(j);
            }
        }
        return dp[0][0];
    }

    /**
     * 复原IP地址
     *
     * @param s
     * @return
     */
    public List<String> restoreIpAddresses(String s) {
        //ip地址的每一位>0  <256
        List<String> res = new ArrayList<>();
        return res;
    }

    private void dfsIP(List<String> res, String temp, String s, int begin) {
        if (temp.length() == s.length() + 3) {
            res.add(temp);
        } else {
            for (int i = begin; i < begin + 3; i++) {
                if (!"".equals(temp)) {
                    temp += ",";
                }
                if (begin > s.length()) {
                    i = s.length() - begin + 1;
                    temp += s.substring(begin, i);
                    break;
                }


            }
        }
    }

    /**
     * 反转从m到n位置的链表
     *
     * @param head
     * @param m
     * @param n
     * @return
     */
    public static ListNode reverseBetween(ListNode head, int m, int n) {
        int i = m;
        ListNode top = null, tail = null, dummyHead = new ListNode(0), cur = dummyHead;
        dummyHead.next = head;
        while (i - 1 > 0) {
            cur = cur.next;
            i--;
        }
        top = cur;//截取前面的节点给top
        ListNode reverseNode = top.next;
        i = n - m;
        while (i >= 0) {
            cur = cur.next;
            i--;
        }
        tail = cur.next;//截取尾部节点给tail

        cur.next = null;//对截取的节点，尾部置为null
        ListNode pre = null;
        cur = reverseNode;
        while (cur != null) {
            ListNode nextTemp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nextTemp;
        }
        top.next = pre;
        reverseNode.next = tail;
        return dummyHead.next;

    }

    /**
     * 解码方法 1-26的数字对应字符 比如26可解为BF和Z
     *
     * @param s
     * @return
     */
    public static int numDecodings(String s) {
        int n = s.length();
        int[] dp = new int[n + 1];
        if (s.charAt(0) != '0') dp[1] = dp[0] = 1;
        for (int i = 2; i <= n; i++) {
            if (s.charAt(i - 1) == '0') {
                if (s.charAt(i - 2) == '1' || s.charAt(i - 2) == '2')
                    dp[i] = dp[i - 2];
                else
                    return 0;
            } else {
                dp[i] = dp[i - 1];
                if (s.charAt(i - 2) != '0') {
                    int t = 10 * (s.charAt(i - 2) - '0') + s.charAt(i - 1) - '0';
                    if (t <= 26)
                        dp[i] += dp[i - 2];
                }
            }
        }
        return dp[n];
    }


    /**
     * 查找元素是否存在旋转后的有序数组中，相比第一类，第二类中可能会有重复元素
     *
     * @param nums
     * @param target
     * @return
     */
    public static boolean search2(int[] nums, int target) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        return search2(nums, 0, nums.length - 1, target);
    }

    private static boolean search2(int[] nums, int start, int end, int target) {
        if (start > end) {
            return false;
        }
        int mid = (start + end) / 2;
        if (nums[mid] == target) {
            return true;
        }
        //前半段有序
        if (nums[start] < nums[mid]) {
            if (target >= nums[start] && target < nums[mid]) {
                return search2(nums, start, mid - 1, target);
            } else {
                return search2(nums, mid, end, target);
            }
        } else {//前半段无序 后半段有序
            if (target > nums[mid] && target <= nums[end]) {
                return search2(nums, mid + 1, end, target);
            } else {
                return search2(nums, start, mid, target);
            }
        }
    }


    public static int removeDuplicates(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length < 3) {
            return nums.length;
        }
        int i = 1, times = 1, rsp = nums.length, count = 1, pre = nums[0];
        while (times < nums.length && i < nums.length) {
            if (nums[i] == pre) {
                count++;
                if (count > 2) {
                    move(nums, i);
                    count--;
                    rsp--;
                    i--;
                }
            } else {
                pre = nums[i];
                count = 1;
            }
            i++;
            times++;
        }
        return rsp;
    }

    private static void move(int[] nums, int start) {
        int i = start;
        while (i < nums.length) {
            nums[i - 1] = nums[i];
            i++;
        }
    }

    static boolean[][] visited;

    /**
     * 判断单词是否在矩阵中能够连续出现，
     *
     * @param board
     * @param word
     * @return
     */
    public static boolean exist(char[][] board, String word) {
        //还是得用回溯法
        if (board == null || board.length == 0 || word == null || word.length() == 0) {
            return false;
        }
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                visited = new boolean[m][n];
                if (dfsExist(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }

    private static boolean dfsExist(char[][] board, String word, int index, int startX, int startY) {
        if (index == word.length() - 1) {
            return word.charAt(index) == board[startX][startY];
        }
        if (word.charAt(index) == board[startX][startY]) {
            visited[startX][startY] = true;
            if (startX > 0) {
                int i = startX - 1;
                if (!visited[i][startY] && dfsExist(board, word, index + 1, i, startY)) {
                    return true;
                }
            }
            if (startX < board.length - 1) {
                int i = startX + 1;
                if (!visited[i][startY] && dfsExist(board, word, index + 1, i, startY)) {
                    return true;
                }
            }
            if (startY > 0) {
                int i = startY - 1;
                if (!visited[startX][i] && dfsExist(board, word, index + 1, startX, i)) {
                    return true;
                }
            }
            if (startY < board[0].length - 1) {
                int i = startY + 1;
                if (!visited[startX][i] && dfsExist(board, word, index + 1, startX, i)) {
                    return true;
                }
            }
            visited[startX][startY] = false;
        }
        return false;
    }

    /**
     * 对array快速排序
     *
     * @param array  待操作数组
     * @param low    低位
     * @param height 高位
     */
    public static void quickSort(int[] array, int low, int height) {
        // 记录划分后的基准元素所对应的位置
        int temp;
        // 仅当区间长度大于1时才须排序
        if (low < height) {
            // 对array做划分
            temp = quick(array, low, height);
            // 对左区间递归排序
            quickSort(array, low, temp - 1);
            // 对右区间递归排序
            quickSort(array, temp + 1, height);
        }
    }

    /**
     * 分治法划分算法
     *
     * @param array  待操作数组
     * @param low    划分中模块的起始地址
     * @param height 划分中模块的结束地址
     * @return 基准元素的位置下标
     */
    private static int quick(int[] array, int low, int height) {
        // 设置第一个数为基准元素
        int pivot = array[low];
        // 从右向左扫描，查找第1个小于pivot的元素
        while (low < height) {
            while (low < height && array[height] >= pivot) {
                height--;
            }
            // 表示找到了小于pivot的元素
            if (low < height) {
                // 交换后low执行+1操作
                swap(array, low++, height);
            }
            // 从左向右扫描，查找第1个大于pivot的元素
            while (low < height && array[low] <= pivot) {
                low++;
            }
            // 表示找到了大于pivot的元素
            if (low < height) {
                // 交换后heigh执行-1操作
                swap(array, low, height--);
            }
        }
        // 返回基准元素最终位置下标
        return height;
    }


    /**
     * 输出全部子集
     *
     * @param nums
     * @return
     */
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> rsp = new ArrayList<>();
        if (nums == null) {
            return rsp;
        }
        rsp.add(new ArrayList<Integer>());
        dfsSub(rsp, new ArrayList<Integer>(), nums);
        return rsp;
    }

    private void dfsSub(List<List<Integer>> res, List<Integer> temp, int[] nums) {
        if (temp.size() == nums.length) {
            if (!res.contains(temp)) {
                res.add(new ArrayList<>(temp));
            }
        } else {
            for (int i : nums) {
                if (temp.size() == 0 || (!temp.contains(i) && temp.get(temp.size() - 1) < i)) {
                    temp.add(i);
                    res.add(new ArrayList<>(temp));
                    dfsSub(res, temp, nums);
                    temp.remove(temp.size() - 1);
                }
            }
        }
    }

    public static void sortColors(int[] nums) {
        int start = 0, end = nums.length - 1, i = 0;
        while (i <= end) {
            if (nums[i] == 0) {
                swap(nums, start, i++);
                start++;
            } else if (nums[i] == 2) {
                swap(nums, i, end--);
            } else {
                i++;
            }
        }
    }

    /**
     * 矩阵置0 若某一位为0，就将它的行列都置为0
     *
     * @param matrix
     */
    public static void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return;
        }
        int m = matrix.length, n = matrix[0].length;
        boolean[][] flag = new boolean[m][n];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (flag[i][j]) {
                    continue;
                }
                if (matrix[i][j] == 0) {
                    //全部置0
                    for (int k = 0; k < m; k++) {
                        if (matrix[k][j] != 0) {
                            flag[k][j] = true;
                        }
                        matrix[k][j] = 0;
                    }
                    for (int k = 0; k < n; k++) {
                        if (matrix[i][k] != 0) {
                            flag[i][k] = true;
                        }
                        matrix[i][k] = 0;
                    }
                }
            }
        }
    }

    public static String simplifyPath(String path) {
//        if (path.length() < 2) {
//            return path;
//        }
        Stack<String> stack = new Stack<>();
        int i = 0, j = 1;
        while (j < path.length()) {
            //重点在于取每一位 如果末尾为/，就滑动窗口
            while (j < path.length() && path.charAt(j) == '/') {
                i++;
                j++;
            }
            //如果j不是/，就增大j，这样substring的结果末尾就不是/
            while (j < path.length() && path.charAt(j) != '/') {
                j++;
            }
            String temp = path.substring(i, j);
            if ("/..".equals(temp)) {
                if (!stack.isEmpty()) {
                    stack.pop();
                }
            } else if (!"/.".equals(temp) && !"/".equals(temp)) {
                stack.push(temp);
            }
            i = j;
            j = i + 1;
        }
        if (stack.isEmpty()) {
            return "/";
        } else {
            String res = "";
            while (!stack.isEmpty()) {
                res = stack.pop() + res;
            }
            return res;
        }
    }

    /**
     * 最小路径和
     *
     * @param grid
     * @return
     */
    public int minPathSum(int[][] grid) {
        //还是动态规划算法，获取之前节点的最小和
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int m = grid.length, n = grid[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 && j > 0) {
                    grid[i][j] = grid[i][j - 1] + grid[i][j];
                } else if (i > 0 && j == 0) {
                    grid[i][j] = grid[i - 1][j] + grid[i][j];
                } else if (i > 0 && j > 0) {
                    grid[i][j] = Math.min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j];
                }
            }
        }
        return grid[m - 1][n - 1];
    }

    /**
     * 在M*N的方格中要走过的路径数量，若矩阵中某一位置为1，说明该位置有障碍物，不能走
     *
     * @param obstacleGrid
     * @return
     */
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        if (obstacleGrid == null || obstacleGrid.length == 0) {
            return 0;
        }
        int m = obstacleGrid.length, n = obstacleGrid[0].length;
        if (obstacleGrid[0][0] == 1) {
            return 0;
        }
        obstacleGrid[0][0] = 1;
        //从边缘着手，有障碍物的地方，边缘之后的值都是0
        for (int i = 1; i < m; i++) {
            if (obstacleGrid[i][0] != 1) {
                obstacleGrid[i][0] = obstacleGrid[i - 1][0];
            } else {
                obstacleGrid[i][0] = 0;
            }
        }
        for (int i = 1; i < n; i++) {
            if (obstacleGrid[0][i] != 1) {
                obstacleGrid[0][i] = obstacleGrid[0][i - 1];
            } else {
                obstacleGrid[0][i] = 0;
            }
        }
        //边缘处理完后，其他部分有障碍物，都转换成0，然后进入动态规划
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    obstacleGrid[i][j] = 0;
                    continue;
                }
                obstacleGrid[i][j] = obstacleGrid[i - 1][j] + obstacleGrid[i][j - 1];
            }
        }
        return obstacleGrid[m - 1][n - 1];
    }

    /**
     * 在M*N的方格中要走过的路径数量
     *
     * @param m
     * @param n
     * @return
     */
    public int uniquePaths(int m, int n) {
        //动态规划求解 设定一个矩阵，可推导出：每个矩阵的步数=左边+上边 的和
        int[][] record = new int[m][n];
        for (int i = 0; i < m; i++) {
            record[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            record[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                record[i][j] = record[i - 1][j] + record[i][j - 1];
            }
        }
        return record[m - 1][n - 1];
    }

    /**
     * 从二维矩阵中找到变长最大的正方形 动态规划
     *
     * @param matrix
     * @return
     */
    public static int maxSquare(int[][] matrix) {
        if (matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        int M = matrix.length, N = matrix[0].length, res = 0;
        int[][] dp = new int[M][N];
        for (int i = 0; i < M; i++) {
            if (matrix[i][0] == 1) {
                dp[i][0] = 1;
                res = 1;
            }
        }

        for (int j = 0; j < N; j++) {
            if (matrix[0][j] == 1) {
                dp[0][j] = 1;
                res = 1;
            }
        }

        for (int i = 1; i < M; i++) {
            for (int j = 1; j < N; j++) {
                if (matrix[i][j] == 1) {
                    dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }

    /**
     * 从1到N的排列，按顺序输出第k个
     *
     * @param n
     * @param k
     * @return
     */
    public static String getPermutation(int n, int k) {
        //弄错了这题的本意，根本不是考全排列！！！！！！
//        List<String> list = new ArrayList<>();
//        int[] nums = new int[n];
//        for (int i = 1; i <= n; i++) {
//            nums[i - 1] = i;
//        }
//        dfsN(list, nums, 0, n - 1);
//
//        return list.get(k - 1);
        /**
         直接用回溯法做的话需要在回溯到第k个排列时终止就不会超时了, 但是效率依旧感人
         可以用数学的方法来解, 因为数字都是从1开始的连续自然数, 排列出现的次序可以推
         算出来, 对于n=4, k=15 找到k=15排列的过程:

         1 + 对2,3,4的全排列 (3!个)
         2 + 对1,3,4的全排列 (3!个)         3, 1 + 对2,4的全排列(2!个)
         3 + 对1,2,4的全排列 (3!个)-------> 3, 2 + 对1,4的全排列(2!个)-------> 3, 2, 1 + 对4的全排列(1!个)-------> 3214
         4 + 对1,2,3的全排列 (3!个)         3, 4 + 对1,2的全排列(2!个)         3, 2, 4 + 对1的全排列(1!个)

         确定第一位:
         k = 14(从0开始计数)
         index = k / (n-1)! = 2, 说明第15个数的第一位是3
         更新k
         k = k - index*(n-1)! = 2
         确定第二位:
         k = 2
         index = k / (n-2)! = 1, 说明第15个数的第二位是2
         更新k
         k = k - index*(n-2)! = 0
         确定第三位:
         k = 0
         index = k / (n-3)! = 0, 说明第15个数的第三位是1
         更新k
         k = k - index*(n-3)! = 0
         确定第四位:
         k = 0
         index = k / (n-4)! = 0, 说明第15个数的第四位是4
         最终确定n=4时第15个数为3214
         **/

        StringBuilder sb = new StringBuilder();
        // 候选数字
        List<Integer> candidates = new ArrayList<>();
        // 分母的阶乘数
        int[] factorials = new int[n + 1];
        factorials[0] = 1;
        int fact = 1;
        for (int i = 1; i <= n; ++i) {
            candidates.add(i);
            fact *= i;
            factorials[i] = fact;
        }
        k -= 1;
        for (int i = n - 1; i >= 0; --i) {
            // 计算候选数字的index
            int index = k / factorials[i];
            sb.append(candidates.remove(index));
            k -= index * factorials[i];
        }
        return sb.toString();
    }

    private static void dfsN(List<String> rsp, int[] nums, int left, int right) {
        if (left == right) {
            StringBuilder sb = new StringBuilder();
            for (int i : nums) {
                sb.append(i);
            }
            if (!rsp.contains(sb.toString())) {
                rsp.add(sb.toString());
            }
        } else {
            for (int i = left; i <= right; i++) {
                //自增序列，不需要去重
//                if (i != left && nums[left] == nums[i]) {
//                    continue;//去重
//                }
                swap(nums, left, i);
                dfsN(rsp, nums, left + 1, right);
                swap(nums, i, left);
            }
        }
    }

    public static int[][] generateMatrix(int n) {
        if (n <= 0) {
            return new int[][]{};
        }
        int[][] rsp = new int[n][n];
//        int times = n / 2 + n % 2, begin = 1;
//        for (int i = 0; i < times; i++) {
//            //从左到右
//            for (int j = i; j < n; j++) {
//                if (rsp[i][j] == 0) {
//                    rsp[i][j] = begin++;
//                }
//            }
//            //右下
//            for (int j = i; j < n; j++) {
//                if (rsp[j][n - 1 - i] == 0) {
//                    rsp[j][n - 1 - i] = begin++;
//                }
//            }
//            //下左
//            for (int j = n - i - 1; j >= 0; j--) {
//                if (rsp[n - 1 - i][j] == 0) {
//                    rsp[n - 1 - i][j] = begin++;
//                }
//            }
//            //左上
//            for (int j = n - i - 1; j >= 0; j--) {
//                if (rsp[j][i] == 0) {
//                    rsp[j][i] = begin++;
//                }
//            }
//        }
//        return rsp;
        int begin = 1, i = 0;
        while (begin <= n * n) {
            //从左到右
            for (int j = i; j < n - i; i++) {
                rsp[i][j] = begin++;
            }

            //从上到下
            for (int j = i + 1; j < n - i; j++) {
                rsp[j][n - 1 - i] = begin++;
            }
            //从右到左
            for (int j = n - 2 - i; j >= i; j--) {
                rsp[n - 1 - i][j] = begin++;
            }
            //从下到上
            for (int j = n - 2 - i; j > i; j--) {
                rsp[j][i] = begin++;
            }
            i++;
        }
        return rsp;
    }

    /**
     * 最后一个单词的长度
     *
     * @param s
     * @return
     */
    public static int lengthOfLastWord(String s) {
        if (s == null) {
            return 0;
        }
        int i = s.length() - 1, num = 0;
        while (i >= 0) {
            if (s.charAt(i) != ' ') {
                break;
            }
            i--;
        }
        while (i >= 0) {
            if (s.charAt(i) == ' ') {
                break;
            }
            num++;
            i--;
        }
        return num;
    }

    /**
     * 跳跃游戏，当前所处位置即为能够跳跃的最大步数
     *
     * @param nums 数组为非负数组
     * @return
     */
    public boolean canJump(int[] nums) {
        if (nums == null || nums.length == 0) {
            return false;
        }
        int n = nums.length;
        int maxReach = 0;
        for (int i = 0; i < n; i++) {
            if (i > maxReach) {
                break;
            }
            if (maxReach < i + nums[i]) {
                maxReach = i + nums[i];
            }
            if (maxReach >= n - 1) {
                return true;
            }
        }
        return false;
    }

    /**
     * 螺旋矩阵
     *
     * @param matrix
     * @return
     */
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> rsp = new ArrayList<>();
        if (matrix == null || matrix.length == 0) {
            return rsp;
        }
        int rowNum = matrix.length, colNum = matrix[0].length;
        boolean[][] flag = new boolean[rowNum][colNum];
        int times = Math.min(rowNum, colNum) / 2 + Math.min(rowNum, colNum) % 2;
        for (int i = 0; i < times; i++) {
            //从左到右
            for (int j = i; j < colNum - i; j++) {
                if (!flag[i][j]) {
                    rsp.add(matrix[i][j]);
                    flag[i][j] = true;
                }
            }
            //右下
            for (int j = i + 1; j < rowNum - i; j++) {
                if (!flag[j][colNum - 1 - i]) {
                    rsp.add(matrix[j][colNum - 1 - i]);
                    flag[j][colNum - 1 - i] = true;
                }
            }
            //下左
            for (int j = colNum - i - 1; j >= i; j--) {
                if (!flag[rowNum - 1 - i][j]) {
                    rsp.add(matrix[rowNum - 1 - i][j]);
                    flag[rowNum - 1 - i][j] = true;
                }
            }
            //左上
            for (int j = rowNum - i - 1; j >= i; j--) {
                if (!flag[j][i]) {
                    rsp.add(matrix[j][i]);
                    flag[j][i] = true;
                }
            }
        }
        return rsp;
    }

    /**
     * 最大子序和
     *
     * @param nums
     * @return
     */
    public int maxSubArray(int[] nums) {
        return 0;
    }

    /**
     * 实现pow
     *
     * @param x
     * @param n
     * @return
     */
    public double myPow(double x, int n) {
        //感觉可以试试二分法 折半计算
        double res = 1.0;
        for (int i = n; i != 0; i /= 2) {
            if (i % 2 != 0) {
                res *= x;
            }
            x *= x;
        }
        return n < 0 ? 1 / res : res;
    }

    /**
     * 字母异位词分组
     *
     * @param strs
     * @return
     */
    public static List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> rsp = new ArrayList<>();
        if (strs == null || strs.length == 0) {
            return rsp;
        }
        Map<String, List<String>> map = new HashMap<>();
        for (String str : strs) {
            boolean flag = false;
            for (String item : map.keySet()) {
                if (isValid(item, str)) {
                    map.get(item).add(str);
                    flag = true;
                }
            }
            if (!flag) {
                List<String> list = new ArrayList<>();
                list.add(str);
                map.put(str, list);
            }
        }
        for (List<String> item : map.values()) {
            rsp.add(item);
        }
        return rsp;
    }

    private static boolean isValid(String key, String str) {
        if (key.length() != str.length()) {
            return false;
        }
        char[] keyArr = key.toCharArray();
        char[] strArr = str.toCharArray();
        Arrays.sort(keyArr);
        Arrays.sort(strArr);
        return String.valueOf(keyArr).equals(String.valueOf(strArr));
    }

    /**
     * 旋转矩阵 顺时针旋转90度
     *
     * @param matrix
     */
    public static void rotate(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }

        int len = matrix.length;
        for (int i = 0; i < len / 2; i++) {
            int start = i;
            int end = len - i - 1;
            for (int j = 0; j < end - start; j++) {
                int temp = matrix[start][start + j];
                matrix[start][start + j] = matrix[end - j][start];
                matrix[end - j][start] = matrix[end][end - j];
                matrix[end][end - j] = matrix[start + j][end];
                matrix[start + j][end] = temp;
            }
        }

        //好办法 看懂了
//        int col = matrix[0].length - 1;
//        int row = matrix.length - 1;
//        int colF = col;
//        int rowF = row;
//        for (int r = 0; r < rowF; r++) {
//            for (int c = r; c < colF; c++) {
//                int x1 = r;
//                int y1 = c;
//
//                int x2 = c;
//                int y2 = col - r;
//
//                int x3 = row - r;
//                int y3 = col - c;
//
//                int x4 = row - c;
//                int y4 = r;
//
//                swap(matrix, x1, y1, x2, y2);
//                swap(matrix, x1, y1, x3, y3);
//                swap(matrix, x1, y1, x4, y4);
//            }
//            rowF--;
//            colF--;
//        }
    }

    public static void swap(int[][] matrix, int x1, int y1, int x2, int y2) {
        int temp = matrix[x1][y1];
        matrix[x1][y1] = matrix[x2][y2];
        matrix[x2][y2] = temp;
    }

    /**
     * 全排列 包含重复元素，返回所有不重复的排列方式
     *
     * @param nums
     * @return
     */
    public static List<List<Integer>> permuteUnique(int[] nums) {
        Set<List<Integer>> set = new HashSet<>();
        List<List<Integer>> list = new ArrayList<>();
        sortAll(nums, 0, nums.length - 1, set);
//        Set<List<Integer>> set = map.keySet();
        for (List<Integer> arr : set) {
            list.add(arr);
        }
        return list;
    }

    private static void sortAll(int arr[], int i, int j, Set<List<Integer>> set) {
        if (i == j) {
            List<Integer> list = new ArrayList<>();
            for (int k : arr) {
                list.add(k);
            }
            set.add(list);
        }
        for (int k = i; k <= j; k++) {
            //换完后进行排列组合
            //有点明白了，先同位置交换（没变），然后下一行i+1，不断延续，最终会输出默认排列；同一层再循环，会让第一位与第二位交换，然后最终输出第一与第二交换的排列，一次类推
            swap(arr, k, i);
            sortAll(arr, i + 1, j, set);
            //排列组合后再换回来
            swap(arr, k, i);
        }
    }


    /**
     * 组合综合，数组中每个元素只能取用一次
     *
     * @param candidates 数组中可能存在重复元素
     * @param target
     * @return
     */
    public static List<List<Integer>> combinationSum2(int[] candidates, int target) {
        int len = candidates.length;
        Arrays.sort(candidates);
        List<List<Integer>> list = new ArrayList<>();
        if (len == 0) {
            return list;
        }
        dfsCombinationSum2(list, new ArrayList<Integer>(), candidates, target, 0);
        return list;
    }

    private static void dfsCombinationSum2(List<List<Integer>> list, List<Integer> res, int[] candidates, int target, int k) {
        //结束条件 res里的总和>=target
        int sum = getSum(res);
        if (sum >= target) {
            if (sum == target) {
                list.add(new ArrayList<>(res));
            }
        } else {
            for (int i = k; i < candidates.length; i++) {
                //因为当前层，再取下一个如果一样的数的话，就会造成重复，但是在下一层加入就不会，因为当前层是替换，如果拿一个一样的替换肯定会重复
                //懂了 妙啊！ 比如 会有两个1，2,5  两个1,7  因为1有两个
                if (i > k && candidates[i] == candidates[i - 1]) {
                    continue;
                }
                res.add(candidates[i]);
                dfsCombinationSum2(list, res, candidates, target, i + 1);
                res.remove(res.size() - 1);
            }
        }
    }

    /**
     * 组合总和 数组中的元素可以无限制取用
     *
     * @param candidates 数组中无重复元素
     * @param target
     * @return
     */
    public static List<List<Integer>> combinationSum(int[] candidates, int target) {
        int len = candidates.length;
        List<List<Integer>> list = new ArrayList<>();
        if (len == 0) {
            return list;
        }
        dfs(list, new ArrayList<Integer>(), candidates, target, 0);
        return list;
    }

    private static void dfs(List<List<Integer>> list, List<Integer> res, int[] candidates, int target, int k) {
        //结束条件 res里的总和>=target
        int sum = getSum(res);
        if (sum >= target) {
            if (sum == target) {
                list.add(new ArrayList<>(res));
            }
        } else {
            for (int i = k; i < candidates.length; i++) {
                res.add(candidates[i]);
                dfs(list, res, candidates, target, i);
                res.remove(res.size() - 1);
            }
        }
    }

    private static int getSum(List<Integer> res) {
        int sum = 0;
        for (int i : res) {
            sum += i;
        }
        return sum;
    }

    /**
     * 全排列(给定数组的全部排列)
     *
     * @param nums 数组没有重复数字
     * @return
     */
    public static List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> rsp = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return rsp;
        }
        dfs(rsp, new ArrayList<Integer>(), nums);
        return rsp;
    }

    private static void dfs(List<List<Integer>> res, List<Integer> tmp, int[] nums) {
        if (tmp.size() == nums.length) {
            res.add(new ArrayList<>(tmp));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (!tmp.contains(nums[i])) {
                tmp.add(nums[i]);
                dfs(res, tmp, nums);
                tmp.remove(tmp.size() - 1);
            }
        }
    }

    /**
     * 报数
     *
     * @param n
     * @return
     */
    public static String countAndSay(int n) {
        String rsp = "1";
        for (int i = 1; i < n; i++) {
            rsp = count(rsp);
        }
        return rsp;
    }

    private static String count(String content) {
        StringBuilder sb = new StringBuilder();
        int i = 1;
        int count = 1;
        char preChar = content.charAt(0);
        while (i < content.length()) {
            char c = content.charAt(i);
            if (preChar != c) {
                sb.append(count).append(preChar);
                count = 1;
                preChar = c;
            } else {
                count++;
            }
            i++;
        }
        sb.append(count).append(preChar);
        return sb.toString();
    }

    public boolean isValidSudoku(char[][] board) {
        if (board == null || board.length < 9) {
            return false;
        }
        //遍历每个节点 判断行列是否有重复
        for (int i = 0; i < board.length; i++) {
            int[] rowFlag = new int[9];
            int[] colFlag = new int[9];
            for (int j = 0; j < board[0].length; j++) {
                if (rowFlag[board[i][j]] == 0) {
                    rowFlag[board[i][j]] = 1;
                } else {
                    return false;
                }
                if (colFlag[board[j][i]] == 0) {
                    colFlag[board[j][i]] = 1;
                } else {
                    return false;
                }

                //判断九宫格内是否有重复
                if (i % 3 == 0 && j % 3 == 0) {
                    int[] nineFlag = new int[9];
                    for (int k = i; k < i + 3; k++) {
                        for (int l = j; l < j + 3; l++) {
                            if (nineFlag[board[k][l]] == 0) {
                                nineFlag[board[k][l]] = 1;
                            } else {
                                return false;
                            }
                        }
                    }
                }
            }
        }
        return true;
    }


    /**
     * 从一个旋转后的数组中，找到target的index
     *
     * @param nums
     * @param target
     * @return
     */
    public int search(int[] nums, int target) {
        return 0;
    }

    //二分法查找
    private int search(int[] nums, int begin, int end, int target) {
        int mid = (begin + end) / 2;
        if (begin > end) {
            return -1;
        }
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[mid] < nums[end]) {
            if (nums[mid] < target && target <= nums[end]) {
                return search(nums, mid, end, target);
            } else {
                return search(nums, begin, mid, target);
            }
        } else {
            if (nums[begin] <= target && target < nums[mid]) {
                return search(nums, begin, mid, target);
            } else {
                return search(nums, mid, end, target);
            }
        }
    }

    /**
     * 下一个最大排列
     *
     * @param nums
     */
    public void nextPermutation(int[] nums) {
        if (nums != null && nums.length > 0) {
            //从后到前，找到第一个递增的点
            int i = nums.length - 1;
            while (i > 0 && nums[i] <= nums[i - 1]) {
                i--;
            }
            //存在第一个递增点，从后面找到第一个比它大的值
            if (i > 0) {
                int j = nums.length - 1;
                while (nums[j] <= nums[i]) {
                    j--;
                }
                int temp = nums[j];
                nums[j] = nums[i];
                nums[i] = temp;
            }
            //reverse 自i+1之后的数组，让其单调递增
            reverse(nums, i + 1, nums.length - 1);
        }
    }

    private void reverse(int[] nums, int start, int end) {
        while (start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }

    private static void swap(int[] nums, int src, int target) {
        int temp = nums[src];
        nums[src] = nums[target];
        nums[target] = temp;
    }

    /**
     * 实现indexOf
     *
     * @param haystack
     * @param needle
     * @return
     */
    public static int strStr(String haystack, String needle) {
        if (haystack == null || needle == null || haystack.length() < needle.length()) {
            return -1;
        }
        if ("".equals(needle)) {
            return 0;
        }
        int i = 0;
        while (i <= haystack.length() - needle.length()) {
            if (isValid(haystack, needle, i)) {
                return i;
            }
            i++;
        }
        return -1;
    }

    private static boolean isValid(String haystack, String needle, int start) {
        int i = 0;
        while (i < needle.length()) {
            if (haystack.charAt(start) != needle.charAt(i)) {
                return false;
            }
            start++;
            i++;
        }
        return true;
    }

    /**
     * 移除相似元素
     *
     * @param nums
     * @param val
     * @return
     */
    public int removeElement(int[] nums, int val) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int i = 0, j = 0;
        while (i < nums.length) {
            if (nums[i] != val) {
                nums[j] = nums[i];
                j++;
            }
            i++;
        }
        return j;
    }

    /**
     * 输出一个数字的补数（二进制取反）
     *
     * @param num
     * @return
     */
    public int findComplement(int num) {
        String s = Integer.toBinaryString(num);
        int i = 0, rsp = 0;
        while (i < s.length()) {
            if (s.charAt(i) == '1') {
                rsp += Math.pow(2, s.length() - i - 1);
            }
            i++;
        }
        return rsp;
    }

    /**
     * 供暖器供暖
     *
     * @param houses  房屋位置
     * @param heaters 暖气位置
     * @return
     */
    public int findRadius(int[] houses, int[] heaters) {
        if (houses == null || heaters == null) {
            return 0;
        }
        int[] distance = new int[houses.length];
        for (int i = 0; i < houses.length; i++) {
            distance[i] = -1;
            for (int heat : heaters) {
                int dis = Math.abs(heat - houses[i]);
                if (distance[i] == -1 || distance[i] > dis) {
                    distance[i] = dis;
                }
            }
        }
        //返回distance数组中最小的值
        int min = distance[0], i = 1;
        while (i < distance.length) {
            if (distance[i] < min) {
                min = distance[i];
            }
            i++;
        }
        return min;
    }

    /**
     * 岛屿的周长
     *
     * @param grid
     * @return
     */
    public int islandPerimeter(int[][] grid) {
        //重点关注前面遍历过得方格，如果之前有相邻方格，就-2;
        if (grid == null || grid.length == 0) {
            return 0;
        }
        int rsp = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if (grid[i][j] == 1) {
                    rsp += 4;
                    if (i > 0 && grid[i - 1][j] == 1) {
                        rsp -= 2;
                    }
                    if (j > 0 && grid[i][j - 1] == 1) {
                        rsp -= 2;
                    }
                }
            }
        }
        return rsp;
    }

    /**
     * 汉明距离
     *
     * @param x
     * @param y
     * @return
     */
    public static int hammingDistance(int x, int y) {
        String a = Integer.toBinaryString(x);
        String b = Integer.toBinaryString(y);
        int i = a.length() - 1, j = b.length() - 1, rsp = 0;
        while (i >= 0 || j >= 0) {
            char c = i < 0 ? '0' : a.charAt(i);
            char d = j < 0 ? '0' : b.charAt(j);
            if (c != d) {
                rsp++;
            }
            i--;
            j--;
        }
        return rsp;
    }

    /**
     * 重复的子字符串
     *
     * @param s
     * @return
     */
    public static boolean repeatedSubstringPattern(String s) {
        if (s == null || s.length() < 2) {
            return false;
        }
        int i = 1;
        while (i < s.length()) {
            if (s.length() % i == 0) {
                String temp = s.substring(0, i);
                int j = i, k = j + i;
                while (k <= s.length()) {
                    if (!s.substring(j, k).equals(temp)) {
                        break;
                    }
                    j += i;
                    k += i;
                }
                if (k > s.length()) {
                    return true;
                }
            }
            i++;
        }
        return false;
    }

    /**
     * 给孩子分饼干
     *
     * @param g 孩子
     * @param s 饼干
     * @return
     */
    public int findContentChildren(int[] g, int[] s) {
        if (g == null || s == null) {
            return 0;
        }
        int rsp = 0;
        for (int kid : g) {
            int index = -1;
            for (int i = 0; i < s.length; i++) {
                //找到最接近kid的值
                if (s[i] >= kid) {
                    if (index < 0 || s[i] < s[index]) {
                        index = i;
                    }
                }
            }
            if (index >= 0) {
                rsp++;
                s[index] = -1;
            }
        }
        return rsp;
    }

    /**
     * 最小移动数组
     *
     * @param nums
     * @return
     */
    public static int minMoves(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int times = 0;
        while (!isvalid(nums)) {
            times += move(nums);
        }
        return times;
    }

    private static int move(int[] nums) {
        int i = 1, bigIndex = 0, secondIndex = -1;
        //找最大值
        while (i < nums.length) {
            if (nums[i] > nums[bigIndex]) {
                bigIndex = i;
            }
            i++;
        }
        //找次大值
        i = 0;
        while (i < nums.length) {
            if (i != bigIndex && secondIndex == -1 && nums[i] != nums[bigIndex]) {
                secondIndex = i;
            }
            if (secondIndex != -1 && i != bigIndex && nums[i] > nums[secondIndex] && nums[i] < nums[bigIndex]) {
                secondIndex = i;
            }
            i++;
        }
        //不能一步一步的移动，步数 = 最大值 - 次大值
        int step = nums[bigIndex] - nums[secondIndex];
        for (int j = 0; j < nums.length; j++) {
            if (j != bigIndex) {
                nums[j] += step;
            }
        }
        return step;
    }

    private static boolean isvalid(int[] nums) {
        int i = 1;
        while (i < nums.length) {
            if (nums[i - 1] != nums[i]) {
                return false;
            }
            i++;
        }
        return true;
    }

    /**
     * 数单词
     *
     * @param s
     * @return
     */
    public static int countSegments(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        s = s.trim();
        int i = 1;
        int rsp = 0;
        while (i < s.length()) {
            if (s.charAt(i) == ' ') {
                rsp++;
            }
            while (i < s.length() && s.charAt(i) == ' ') {
                i++;
            }
            i++;
        }
        return rsp;
    }

    /**
     * 压缩字符串
     *
     * @param chars
     * @return
     */
    public static int compress(char[] chars) {
        if (chars == null || chars.length == 0) {
            return 0;
        }
        if (chars.length == 1) {
            return 1;
        }
        //双指针法
        int i = 1, j = 0, count = 1;
        while (i < chars.length) {
            if (chars[i] != chars[i - 1]) {
                chars[j++] = chars[i - 1];
                if (count > 1) {
                    j = addCharArray(chars, count, j);
                }
                count = 1;
                if (i == chars.length - 1) {
                    chars[j++] = chars[i];
                }
            } else {
                count++;
                if (i == chars.length - 1) {
                    chars[j++] = chars[i];
                    j = addCharArray(chars, count, j);
                }
            }
            i++;
        }
        return j;
    }

    private static int addCharArray(char[] chars, int num, int index) {
        char[] array = String.valueOf(num).toCharArray();
        for (char c : array) {
            chars[index++] = c;
        }
        return index;
    }

    public List<Integer> findAnagrams2(String s, String p) {
        List<Integer> rsp = new ArrayList<>();
        if (s == null || p == null || s.length() < p.length()) {
            return rsp;
        }
        int i = 0, j = p.length();
        while (j <= s.length()) {
            String temp = s.substring(i, j);
            if (isvalid(temp, p)) {
                rsp.add(i);
            }
            i++;
            j++;
        }
        return rsp;
    }

    private boolean isvalid(String temp, String p) {
        if (temp.length() != p.length()) {
            return false;
        }
        int rsp = 0;
        for (char a : temp.toCharArray()) {
            rsp ^= a;
        }
        for (char b : p.toCharArray()) {
            rsp ^= b;
        }
        return rsp == 0;
    }

    public String addStrings(String num1, String num2) {
        if (num1 == null) {
            return num2;
        }
        if (num2 == null) {
            return num1;
        }
        int carry = 0, i = num1.length() - 1, j = num2.length() - 1;
        String ans = "";
        while (i >= 0 && j >= 0) {
            int sum = num1.charAt(i) - '0' + num2.charAt(j) - '0' + carry;
            ans = sum % 10 + ans;
            carry = sum / 10;
            i--;
            j--;
        }
        while (i >= 0) {
            int sum = num1.charAt(i) - '0' + carry;
            ans = sum % 10 + ans;
            carry = sum / 10;
            i--;
        }
        while (j >= 0) {
            int sum = num2.charAt(j) - '0' + carry;
            ans = sum % 10 + ans;
            carry = sum / 10;
            j--;
        }
        if (carry > 0) {
            ans = carry + ans;
        }
        return ans;
    }

    /**
     * 第三大的数
     *
     * @param nums
     * @return
     */
    public int thirdMax(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        Integer first = null, second = null, third = null;
        for (int i : nums) {
            if (first == null) {
                first = i;
            } else if (i < first) {
                if (second == null) {
                    second = i;
                } else if (i > second) {
                    third = second;
                    second = i;
                } else if (i < second && (third == null || i > third)) {
                    third = i;
                }

            } else if (i > first) {
                if (second != null) {
                    third = second;
                }
                second = first;
                first = i;
            }
        }
        return third == null ? first : third;
    }

    /**
     * 10进制转化为16进制
     *
     * @param num
     * @return
     */
    public static String toHex(int num) {
//        Map<Integer, Character> map = new HashMap<>();
//        map.put(10, 'a');
//        map.put(11, 'b');
//        map.put(12, 'c');
//        map.put(13, 'd');
//        map.put(14, 'e');
//        map.put(15, 'f');
//        StringBuilder sb = new StringBuilder();
//        String s = Integer.toBinaryString(num);
//        int i = s.length() - 1, count = 0, sum = 0;
//        while (i >= 0) {
//            if(s.charAt(i)=='1'){
//                sum += Math.pow(2, count);
//            }
//            count++;
//            if (count == 4 || i == 0) {
//                if (sum < 10) {
//                    sb.append(sum);
//                } else {
//                    sb.append(map.get(sum));
//                }
//                count = 0;
//                sum = 0;
//            }
//            i--;
//        }
//        return sb.reverse().toString();

        //用位移算法
        if (num == 0) {
            return "0";
        }
        char[] hexArray = new char[]{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        String ans = "";
        //第二个条件很重要，负数右移补1，会超出长度，int用16进制表示最长8位
        while (num != 0 && ans.length() < 8) {
            int temp = num & 0xf;
            ans = hexArray[temp] + ans;
            num >>= 4;
        }
        return ans;
    }

    /*
    拿石头游戏
     */
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }


    /**
     * 各位相加
     *
     * @param num
     * @return
     */
    public int addDigits(int num) {
        if (num < 10) {
            return num;
        }

        while (num > 9) {
            num = num / 10 + num % 10;
        }
        return num;
    }

    /**
     * 打家劫舍 动态规划
     *
     * @param nums
     * @return
     */
    public static int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return nums[0];
        }
        if (nums.length == 2) {
            return Math.max(nums[0], nums[1]);
        }
        if (nums.length == 3) {
            return Math.max(nums[0] + nums[2], nums[1]);
        }
        int first = nums[0];
        int second = Math.max(nums[0], nums[1]);
        int third = Math.max(nums[1], nums[0] + nums[2]);
        int max = Math.max(first, second);
        for (int i = 3; i < nums.length; i++) {
            max = Math.max(first + nums[i - 1], second + nums[i]);
            first = second;
            second = third;
            third = max;
        }
        return max;
    }

    /**
     * 爬楼梯的最小消耗，动态规划
     *
     * @param cost
     * @return
     */
    public static int minCostClimbingStairs(int[] cost) {
        int first = 0, second = 0, totalCost = 0;
        for (int i = 0; i < cost.length - 1; i++) {
            if (first + cost[i] > second + cost[i + 1]) {
                totalCost = second + cost[i + 1];
            } else {
                totalCost = first + cost[i];
            }
            first = second;
            second = totalCost;
        }
        return totalCost;
    }

//    public static String reverseWords(String s) {
//        //这题其实更简单点 直接split
//        String[] array = s.split(" ");
//        StringBuilder sb = new StringBuilder();
//        for (int i = array.length - 1; i >= 0; i--) {
//            if ("".equals(array[i])) {
//                continue;
//            }
//            sb.append(array[i].trim());
//            if (i > 0) {
//                sb.append(" ");
//            }
//        }
//        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == ' ') {
//            sb.deleteCharAt(sb.length() - 1);
//        }
//        return sb.toString();
//    }

    /**
     * 阶乘后的0
     *
     * @param n
     * @return
     */
    public static int trailingZeroes(int n) {
        if (n < 5) {
            return 0;
        }
        int i = 1;
        int rsp = 0;
        while (Math.pow(5, i) <= n) {
            rsp += n / Math.pow(5, i);//为什么不用再乘以i，i=1的时候，已经把25包含在内了，第二次是取的25的一个约数
            i++;
        }
        return rsp;
    }

    /**
     * excel标题转序号
     *
     * @param s
     * @return
     */
    public int titleToNumber(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        int rsp = 0;
        for (int i = 0; i < s.length(); i++) {
            rsp = rsp * 26 + s.charAt(i) - 'A' + 1;
        }
        return rsp;
    }

    /**
     * 获取Excel的标题
     *
     * @param n
     * @return
     */
    public static String convertToTitle(int n) {
        if (n <= 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        while (n > 0) {
            sb.append((char) ((n - 1) % 26 + 'A'));
            n = (n - 1) / 26;
        }
        return sb.reverse().toString();
    }

    /**
     * 验证回文字符串
     *
     * @param s
     * @return
     */
    public static boolean isPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return true;
        }
        int i = 0, j = s.length() - 1;
        while (i < j) {
            char a = s.charAt(i);
            char b = s.charAt(j);
            if (isValidChar(a) && isValidChar(b)) {
                if (Character.toLowerCase(a) != Character.toLowerCase(b)) {
                    return false;
                }
                i++;
                j--;
            } else {
                if (!isValidChar(a)) {
                    i++;
                }
                if (!isValidChar(b)) {
                    j--;
                }
            }
        }
        return true;
    }

    private static boolean isValidChar(char c) {
        if (c >= '0' && c <= '9') {
            return true;
        } else if (c >= 'A' && c <= 'Z') {
            return true;
        } else if (c >= 'a' && c <= 'z') {
            return true;
        }
        return false;
    }

    /**
     * 删除重复的节点（所有重复的都删除，一个不留）
     *
     * @param head
     * @return
     */
    public static ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        //用双指针来做
        ListNode cur = new ListNode(0), left = null, right = null;
        cur.next = head;
        head = cur;
        while (cur.next != null) {
            left = cur.next;
            right = left;
            while (right.next != null && right.next.val == left.val) {
                right = right.next;
            }
            if (left == right) {
                cur = cur.next;
            } else {
                cur.next = right.next;
            }
        }
        return head.next;
    }

    /**
     * 旋转链表 leetcode 61
     *
     * @param head
     * @param k
     * @return
     */
    public static ListNode rotateRight(ListNode head, int k) {
        if (head == null || k == 0) {
            return head;
        }

        ListNode cursor = head;
        ListNode tail = null;
        int count = 1;
        //统计总数，并获取尾节点
        while (cursor.next != null) {
            count++;
            cursor = cursor.next;

        }
        tail = cursor;
        //要对k取余
        int loop = count - k % count;
        tail.next = head;//循环链表
        cursor = head;
        for (int i = 0; i < loop; i++) {
            cursor = cursor.next;
            tail = tail.next;
        }
        tail.next = null;
        return cursor;
    }

    /**
     * 获取数组卡牌分组（其实是找最大公约数）
     *
     * @param deck
     * @return
     */
    public static boolean hasGroupsSizeX(int[] deck) {
        if (deck == null || deck.length == 0) {
            return false;
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i : deck) {
            map.put(i, map.containsKey(i) ? map.get(i) + 1 : 1);
        }
        //求最大公约数
        int division = 0;
        for (int i : map.values()) {
            if (i < 2) {
                return false;
            }
            if (division == 0) {
                division = i;
            }
        }
        while (division > 0) {
            for (int i : map.values()) {
                if (i % division != 0) {
                    division--;
                    break;
                }
            }
            break;
        }

        if (division >= 2) {
            return true;
        }
        return false;
    }

    /**
     * 至少是其他数字两倍的最大数
     *
     * @param nums
     * @return
     */
    public int dominantIndex(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        int minIndex = 0;
        int maxIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
        }
        return nums[maxIndex] / nums[minIndex] >= 2 ? maxIndex : -1;
    }

    //返回第一个中心索引
    public int pivotIndex(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }
        if (nums.length == 1) {
            return 0;
        }
        int i = 0;
        while (i < nums.length) {
            int sumLeft = 0;
            int j = 0;
            while (j < i) {
                sumLeft += nums[j];
                j++;
            }
            int sumRight = 0;
            int k = nums.length - 1;
            while (k > i) {
                sumRight += nums[k];
                k--;
            }
            if (sumLeft == sumRight) {
                return i;
            }
            i++;
        }
        return -1;
    }

    /**
     * 数组的度，返回最小连续子数组的长度
     *
     * @param nums
     * @return
     */
    public static int findShortestSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        Map<Integer, int[]> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int[] numbers = map.getOrDefault(nums[i], new int[3]);
            numbers[0]++;
            if (numbers[1] == 0) {
                numbers[1] = i + 1;
            }
            numbers[2] = i + 1;
            map.put(nums[i], numbers);
        }
        //对map进行计算
        int freq = 0;
        int rsp = 0;
        for (int[] value : map.values()) {
            if (value[0] >= freq) {
                freq = value[0];
                rsp = Math.min(rsp, value[2] - value[1] + 1);
            }
        }
        return rsp;
    }

    /**
     * 最大连续递增数列
     *
     * @param nums
     * @return
     */
    public int findLengthOfLCIS(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        if (nums.length == 1) {
            return 1;
        }
        int rsp = 1;
        int rspTemp = 1;
        int i = 0;
        while (i < nums.length - 1) {
            if (nums[i] < nums[i + 1]) {
                rspTemp++;
            } else {
                rsp = Math.max(rsp, rspTemp);
                rspTemp = 1;
            }
            i++;
        }
        rsp = Math.max(rsp, rspTemp);
        return rsp;
    }

    /**
     * 非递减数列
     *
     * @param nums
     * @return
     */
    public boolean checkPossibility(int[] nums) {
        if (nums == null || nums.length < 3) {
            return true;
        }

        //查看递增数量
        int count = 0;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] < nums[i - 1]) {
                count++;
                if (count > 1) {
                    return false;
                }
                int privous = i > 1 ? nums[i - 2] : 0;
                int after = i < nums.length - 1 ? nums[i + 1] : 10000;
                if (nums[i - 1] > after && nums[i] < privous) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 最长乱序数组
     *
     * @param nums
     * @return
     */
    public static int findUnsortedSubarray(int[] nums) {
        if (nums == null || nums.length == 0 || nums.length == 1) {
            return 0;
        }
        int[] tempArray = nums.clone();
        Arrays.sort(nums);

        int begin = 0, end = nums.length - 1;
        while (begin < end) {
            if (nums[begin] != tempArray[begin]) {
                break;
            }
            begin++;
        }
        while (end > 0) {
            if (nums[end] != tempArray[end]) {
                break;
            }
            end--;
        }
        if (begin > end) {
            return 0;
        }
        return end - begin + 1;
    }

    /**
     * 图片平滑器
     *
     * @param M
     * @return
     */
    public static int[][] imageSmoother(int[][] M) {
        if (M == null || M.length == 0 || M[0].length == 0) {
            return new int[][]{};
        }
        int row = M.length;
        int col = M[0].length;
        int[][] rsp = new int[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                int pointCount = 0;
                int sum = 0;
                //获取周围的点
                if (i - 1 >= 0) {
                    sum += M[i - 1][j];
                    pointCount++;
                    if (j - 1 >= 0) {
                        sum += M[i - 1][j - 1];
                        sum += M[i][j - 1];
                        pointCount += 2;
                    }
                    if (j + 1 < col) {
                        sum += M[i - 1][j + 1];
                        sum += M[i][j + 1];
                        pointCount += 2;
                    }
                }
                if (i + 1 < row) {
                    sum += M[i + 1][j];
                    pointCount++;
                    if (j - 1 >= 0) {
                        sum += M[i + 1][j - 1];
                        pointCount++;
                    }
                    if (j + 1 < col) {
                        sum += M[i + 1][j + 1];
                        pointCount++;
                    }
                }
                rsp[i][j] = sum / pointCount;
            }
        }
        return rsp;
    }

    private static int getVal(int[][] M, int i, int j, int row, int col) {
        int sum = 0;
        int pointCount = 0;
        //获取周围的点
        if (i - 1 >= 0) {
            sum += M[i - 1][j];
            pointCount++;
            if (j - 1 >= 0) {
                sum += M[i - 1][j - 1];
                sum += M[i][j - 1];
                pointCount += 2;
            }
            if (j + 1 < col) {
                sum += M[i - 1][j + 1];
                sum += M[i][j + 1];
                pointCount += 2;
            }
        }
        if (i + 1 < row) {
            sum += M[i + 1][j];
            pointCount++;
            if (j - 1 >= 0) {
                sum += M[i + 1][j - 1];
                pointCount++;
            }
            if (j + 1 < col) {
                sum += M[i + 1][j + 1];
                pointCount++;
            }
        }

        if (pointCount != 0) {
            return sum / pointCount;
        }
        return 0;
    }

    /**
     * 重塑矩阵
     *
     * @param nums
     * @param r
     * @param c
     * @return
     */
    public static int[][] matrixReshape(int[][] nums, int r, int c) {
        if (nums == null || nums.length == 0) {
            return new int[][]{};
        }
        if (r <= 0 || c <= 0) {
            return nums;
        }
        int row = nums.length;
        int col = nums[0].length;

        if (row * col <= (r - 1) * c) {
            return nums;
        }
        int[][] rsp = new int[r][c];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                int tempIndex = i * col + j;
                int newRow = tempIndex / c;
                int newCol = tempIndex % c;
                rsp[newRow][newCol] = nums[i][j];
            }
        }
        return rsp;
    }

    /**
     * 反转charArray 数组
     *
     * @param input 数组结束符为'\0'
     * @return
     */
    public static char[] reverse(char[] input) {
        if (input == null || input.length == 0) {
            return new char[]{};
        }
        int length = 0;
        while (input[length] != '\0') {
            length++;
        }
        //反转数组，最后一位是'\0' 不用反转
        swap(input, 0, length - 1);
        //反转单个单词
        int begin = 0, end = 0;
        while (begin < length - 1) {
            while (input[begin] == ' ' && begin < length - 1) {
                begin++;
            }
            end = begin + 1;
            while (input[end] != ' ' && end < length) {
                end++;
            }
            swap(input, begin, end - 1);
            begin = end + 1;
        }
        return input;
    }

    private static void swap(char[] array, int begin, int end) {
        while (begin < end) {
            char temp = array[begin];
            array[begin] = array[end];
            array[end] = temp;
            begin++;
            end--;
        }
    }


    /**
     * 找出所有的字母异位词
     *
     * @param s
     * @param p
     * @return
     */
    public static List<Integer> findAnagrams(String s, String p) {
        List<Integer> rsp = new ArrayList<>();
        if (s == null || p == null) {
            return rsp;
        }
        char origin = 0;
        for (int i = 0; i < p.length(); i++) {
            origin ^= p.charAt(i);
        }
        for (int i = 0; i < s.length() - p.length() + 1; i++) {
            char isSame = origin;
            for (int j = i; j < i + p.length(); j++) {
                isSame ^= s.charAt(j);
            }
            if (isSame == 0) {
                rsp.add(i);
            }
        }
        return rsp;
    }

    /**
     * 找不同
     *
     * @param s
     * @param t
     * @return
     */
    public static char findTheDifference(String s, String t) {
        if (s == null || t == null) {
            return Character.MIN_VALUE;
        }
        short rsp = 0;
        for (int i = 0; i < s.length(); i++) {
            rsp ^= s.charAt(i);
        }
        for (int i = 0; i < t.length(); i++) {
            rsp ^= t.charAt(i);
        }
        return (char) rsp;
    }


    /**
     * 字符串中第一个唯一字符
     *
     * @param s
     * @return
     */
    public static int firstUniqChar(String s) {
        if (s == null) {
            return -1;
        }
        Map<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < s.length(); i++) {
            Character c = s.charAt(i);
            map.put(c, map.containsKey(c) ? map.get(c) + 1 : 1);
        }
        for (int i = 0; i < s.length(); i++) {
            if (map.get(s.charAt(i)) == 1) {
                return i;
            }
        }
        return -1;
    }

    /**
     * 回旋镖
     *
     * @param points
     * @return
     */
    public int numberOfBoomerangs(int[][] points) {
        int result = 0;
        Map<Integer, Integer> map;
        for (int i = 0; i < points.length; i++) {
            map = new HashMap<>();
            for (int j = 0; j < points.length; j++) {
                // 不考虑当前同样的点
                if (i != j) {
                    int distance = getDistance(points[i], points[j]);
                    map.put(distance, map.getOrDefault(distance, 0) + 1);
                }
            }
            result += getCountByPoint(map);
        }

        return result;
    }

    /**
     * 求两点之间的距离的平方, 不进行平方根操作了, 不然可能会涉及到浮点数问题
     *
     * @param pointA
     * @param pointB
     * @return
     */
    private int getDistance(int[] pointA, int[] pointB) {
        int x = pointA[0] - pointB[0];
        int y = pointA[1] - pointB[1];
        return x * x + y * y;
    }

    /**
     * 根据点的数量返回回旋镖的数量
     *
     * @return
     */
    private int getCountByPoint(Map<Integer, Integer> map) {
        int result = 0;
        for (Integer value : map.values()) {
            if (value > 1) {
                // 从n个点中选取两个点的方案数量为(n * n - 1)
                result += value * (value - 1);
            }
        }
        return result;
    }

    /**
     * 最长回文子串
     *
     * @param s
     * @return
     */
    public static String longestPalindromeSon(String s) {
        //暴力法
//        if (s == null) {
//            return "";
//        }
//        String rsp = "";
//        for (int i = 1; i <= s.length(); i++) {
//            for (int j = 0; j < i; j++) {
//                String temp = s.substring(j, i);
//                if (isValid(temp)) {
//                    rsp = temp.length() > rsp.length() ? temp : rsp;
//                }
//            }
//        }
//        return rsp;

        //中心扩展算法
        if (s == null || s.length() <= 0) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);

    }

    private static int expandAroundCenter(String s, int left, int right) {
        int l = left, r = right;
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        return r - l - 1;
    }

    /**
     * 回文子串
     *
     * @param s
     * @return
     */
    public static int countSubstrings(String s) {
        if (s == null) {
            return 0;
        }
        int rsp = 0;
        for (int i = 1; i <= s.length(); i++) {
            for (int j = 0; j < i; j++) {
                String temp = s.substring(j, i);
                if (isValid(temp)) {
                    rsp++;
                }
            }
        }
        return rsp;
    }

    private static boolean isValid(String s) {
        int len = s.length();
        for (int i = 0; i < len / 2; i++) {
            if (s.charAt(i) != s.charAt(len - 1 - i)) {
                return false;
            }
        }
        return true;
    }


    public static int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        for (int i : nums1) {
            for (int j : nums2) {
                if (i == j) {
                    set.add(i);
                }
            }
        }
        int[] res = new int[set.size()];
        int i = 0;
        Iterator<Integer> iterator = set.iterator();
        while (iterator.hasNext()) {
            res[i] = iterator.next();
            i++;
        }
        return res;
    }

    public static int reverseBits(int n) {
//        String str = Integer.toBinaryString(n);
//        StringBuilder src = new StringBuilder();
//        for (int i = 0; i < 32 - str.length(); i++) {
//            src.append("0");
//        }
//        src.append(str);
//
//        StringBuilder sb = new StringBuilder();
//        for (int i = src.length() - 1; i >= 0; i--) {
//            sb.append(src.charAt(i));
//        }
//        return Integer.parseInt(sb.toString(), 2);
        //试试另一种方法
//        return Integer.reverse(n);
        //再试试另一种方法
        int ans = 0, i = 32;
        while (i > 0) {
            ans <<= 1;
            ans += n & 1;
            n >>= 1;
            i--;
        }
        return ans;
    }

    public static int reverse(int x) {
        int posNag = 1;
        if (x < 0) {
            posNag = -1;
        }
        Long rsp = 0L;
        String numStr = String.valueOf(x);
        for (int i = numStr.length() - 1; i >= (posNag < 0 ? 1 : 0); i--) {
            if ("-".equalsIgnoreCase(String.valueOf(numStr.charAt(i)))) {
                continue;
            }
            rsp += Integer.valueOf(String.valueOf(numStr.charAt(i))) * myPow(10, (posNag < 0 ? i - 1 : i));
        }
        rsp = rsp * posNag;
        if (rsp > Integer.MAX_VALUE || rsp < Integer.MIN_VALUE) {
            return 0;
        }
        return rsp.intValue();
    }


    public static int myPow(int base, int b) {
        if (b < 0) {
            return 0;
        }
        if (b == 0) {
            return 1;
        }
        if (b == 1) {
            return base;
        }
        int rsp = base;
        for (int i = 1; i < b; i++) {
            rsp *= base;
        }
        return rsp;
    }

    public int romanToInt(String s) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if ((s.charAt(i) == 'I' || s.charAt(i) == 'X' || s.charAt(i) == 'C') && i < s.length() - 1) {
                if (s.substring(i, i + 2).equals("IV")) {
                    count = count + 4;
                    i = i + 1;
                    continue;
                }
                if (s.substring(i, i + 2).equals("IX")) {
                    count = count + 9;
                    i = i + 1;
                    continue;
                }
                if (s.substring(i, i + 2).equals("XL")) {
                    count = count + 40;
                    i = i + 1;
                    continue;
                }
                if (s.substring(i, i + 2).equals("XC")) {
                    count = count + 90;
                    i = i + 1;
                    continue;
                }
                if (s.substring(i, i + 2).equals("CD")) {
                    count = count + 400;
                    i = i + 1;
                    continue;
                }
                if (s.substring(i, i + 2).equals("CM")) {
                    count = count + 900;
                    i = i + 1;
                    continue;
                }
            }
            if (s.charAt(i) == 'I') {
                count++;
                continue;
            }
            if (s.charAt(i) == 'V') {
                count = count + 5;
                continue;
            }
            if (s.charAt(i) == 'X') {
                count = count + 10;
                continue;
            }
            if (s.charAt(i) == 'L') {
                count = count + 50;
                continue;
            }
            if (s.charAt(i) == 'C') {
                count = count + 100;
                continue;
            }
            if (s.charAt(i) == 'D') {
                count = count + 500;
                continue;
            }
            if (s.charAt(i) == 'M') {
                count = count + 1000;
                continue;
            }
        }
        return count;
    }

    public static String longestCommonPrefix(String[] strs) {
        String rsp = "";
        boolean isPre = true;
        if (strs.length == 0) {
            return rsp;
        }
        while (isPre) {
            for (String item : strs) {
                if (!item.startsWith(rsp)) {
                    isPre = false;
                    if (rsp.length() > 0) {
                        rsp = rsp.substring(0, rsp.length() - 1);
                    }
                    break;
                }
            }
            if (isPre) {
                if (strs[0].length() > rsp.length()) {
                    rsp += strs[0].substring(rsp.length(), rsp.length() + 1);
                }
            }
        }
        return rsp;
    }

    public String convert(String s, int numRows) {
        StringBuilder rsp = new StringBuilder();
        List<StringBuilder> list = new ArrayList<StringBuilder>(numRows);
        for (int i = 0; i < numRows; i++) {
            list.add(new StringBuilder());
        }

        boolean goingDown = false;
        int row = 0;
        for (int i = 0; i < numRows; i++) {
            char c = s.charAt(i);
            list.get(0).append(c);
            if (row == 0 || row == numRows - 1) {
                goingDown = !goingDown;
            }
            row += goingDown ? 1 : -1;
        }
        for (StringBuilder sb : list) {
            rsp.append(sb);
        }
        return rsp.toString();
    }

    public String numToRoman(int num) {
        //换一种思路
        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String[] reps = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        StringBuilder res = new StringBuilder();
        for (int i = 0; i < 13; i++) {
            while (num >= values[i]) {
                num -= values[i];
                res.append(reps[i]);
            }
        }
        return res.toString();

    }

    public static List<List<Integer>> threeSum(int[] nums) {
        if (nums.length < 3) {
            return new ArrayList<>();
        }
        Arrays.sort(nums);
        List<List<Integer>> rsp = new ArrayList<>();
        List<String> list = new ArrayList<>();

        for (int i = 0; i < nums.length - 2; i++) {
            int head = i + 1;
            int tail = nums.length - 1;
            while (nums[i] + nums[head] + nums[tail] < 0 && head < tail - 1) {
                head++;
            }
            while (nums[i] + nums[head] + nums[tail] > 0 && head < tail - 1) {
                tail--;
            }

            while (nums[i] + nums[head] + nums[tail] == 0 || tail - head > 1) {
                if (nums[i] + nums[head] + nums[tail] == 0) {
                    String flag = String.valueOf(nums[i]) + String.valueOf(nums[head]) + String.valueOf(nums[tail]);
                    if (!list.contains(flag)) {
                        List<Integer> temp = new ArrayList<>(3);
                        temp.add(nums[i]);
                        temp.add(nums[head]);
                        temp.add(nums[tail]);
                        rsp.add(temp);
                        list.add(flag);
                    }
                    if (tail - head > 2) {
                        tail--;
                        head++;
                    } else {
                        break;
                    }
                }

                while (nums[i] + nums[head] + nums[tail] > 0 && head < tail - 1) {
                    tail--;
                }
                while (nums[i] + nums[head] + nums[tail] < 0 && head < tail - 1) {
                    head++;
                }
            }
        }
        return rsp;
    }

    public static int threeSumClosest(int[] nums, int target) {
        int rsp = target;
        if (nums.length < 3) {
            return rsp;
        }
        Arrays.sort(nums);
        for (int i = 0; i < nums.length; i++) {
            int head = i + 1;
            int tail = nums.length - 1;
            while (nums[i] + nums[head] + nums[tail] > target && head < tail - 1) {
                tail--;
            }
            while (nums[i] + nums[head] + nums[tail] < target && head < tail - 1) {
                head++;
            }
            if (nums[i] + nums[head] + nums[tail] == target) {
                return target;
            }

            int temp = nums[i] + nums[head] + nums[tail] - target;
            int temp1 = rsp - target;
            rsp = Math.min(temp, temp1) + target;
        }
        return rsp;
    }

    public static List<List<Integer>> fourSum(int[] nums, int target) {
        if (nums.length < 4) {
            return new ArrayList<>();
        }
        Arrays.sort(nums);
        List<List<Integer>> rsp = new ArrayList<>();
        List<String> flagList = new ArrayList<>();
        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }
                int head = j + 1;
                int tail = nums.length - 1;
                while (head < tail) {
                    int temp = nums[i] + nums[j] + nums[head] + nums[tail];
                    if (temp == target) {
                        List<Integer> list = new ArrayList<>();
                        list.add(nums[i]);
                        list.add(nums[j]);
                        list.add(nums[head]);
                        list.add(nums[tail]);
                        rsp.add(list);
                        while (head < tail && nums[head] == nums[head + 1]) {
                            head++;
                        }
                        head++;
                        tail--;
                    } else if (temp < target) {
                        while (head < tail && nums[head] == nums[head + 1]) {
                            head++;
                        }
                        head++;
                    } else if (temp > target) {
                        while (head < tail && nums[tail] == nums[tail - 1]) {
                            tail--;
                        }
                        tail--;
                    }
                }
            }
        }
        return rsp;
    }

    public ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = dummy;
        while (cur.next != null && cur.next.next != null) {
            ListNode left = cur.next;
            ListNode right = cur.next.next;//用来存储第二个节点
            cur.next = right;//第一个节点下一个为第三个
            left.next = right.next;
            right.next = left;
            cur = left;
        }
        return dummy.next;
    }

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    /**
     * 29 两数相除
     */
    public int divide(int dividend, int divisor) {
        //考虑边界情况 -2^31 / -1
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
        if (dividend == Integer.MIN_VALUE && divisor == 1) {
            return Integer.MIN_VALUE;
        }
        int rsp = 0;
        int carry = (dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0) ? -1 : 1;
        if (divisor == Integer.MIN_VALUE) {
            return dividend == Integer.MIN_VALUE ? 1 : 0;
        }

        if (dividend == Integer.MIN_VALUE) {
            dividend += Math.abs(divisor);
            rsp++;
        }
        dividend = Math.abs(dividend);
        divisor = Math.abs(divisor);
//        while(dividend>=divisor){
//            rsp++;
//            dividend-=divisor;
//        }
//        return rsp*carry;

        //试试另一种解法
        if (divisor > dividend) {
            return rsp * carry;
        }
        while (dividend > 1 && dividend > divisor) {
            int tmp = divisor;
            int cnt = 1;
            while (dividend > (tmp << 1)) {
                if ((tmp << 1) < tmp) {
                    break;//防止左移到尽头会变小
                }
                tmp = tmp << 1;
                cnt = cnt << 1;
            }
            dividend -= tmp;
            rsp += cnt;
        }
        return ((rsp + (dividend < divisor ? 0 : 1)) * carry);
    }

    /**
     * 杨辉三角
     *
     * @param numRows 行数
     * @return
     */
    public static List<List<Integer>> generate(int numRows) {
        if (numRows == 0) {
            return null;
        }
        List<List<Integer>> rsp = new ArrayList<>(numRows);
        rsp.add(new ArrayList<Integer>());
        rsp.get(0).add(1);
        for (int i = 1; i < numRows; i++) {
            List<Integer> preRow = rsp.get(i - 1);
            List<Integer> list = new ArrayList<>(i + 1);
            list.add(1);
            for (int j = 1; j < i; j++) {
                list.add(preRow.get(j - 1) + preRow.get(j));
            }
            list.add(1);
            rsp.add(list);
        }
        return rsp;
    }

    /**
     * 杨辉三角 返回第k行
     *
     * @param rowIndex
     * @return
     */
    public List<Integer> getRow(int rowIndex) {
        if (rowIndex == 0) {
            return null;
        }
        int index = rowIndex++;
        List<List<Integer>> rsp = new ArrayList<>(index);
        rsp.add(new ArrayList<Integer>());
        rsp.get(0).add(1);
        for (int i = 1; i < index; i++) {
            List<Integer> preRow = rsp.get(i - 1);
            List<Integer> list = new ArrayList<>(i + 1);
            list.add(1);
            for (int j = 1; j < i; j++) {
                list.add(preRow.get(j - 1) + preRow.get(j));
            }
            list.add(1);
            rsp.add(list);
        }
        return rsp.get(rowIndex);
    }

    /**
     * 旋转数组
     *
     * @param nums
     * @param k
     */
    public static void rotate(int[] nums, int k) {
        if (k <= 0 || nums.length <= 1) {
            return;
        }
        int length = nums.length;
        //减少循环次数，时间复杂度控制在O(1)
        k %= length;
        for (int i = 0; i < k; i++) {
            int temp = nums[length - 1];
            for (int j = length - 1; j > 0; j--) {
                nums[j] = nums[j - 1];
            }
            nums[0] = temp;
        }
    }

    /**
     * 存在重复元素
     *
     * @param nums
     * @return
     */
    public static boolean containsDuplicate(int[] nums) {
        if (nums.length == 0) {
            return false;
        }
        Arrays.sort(nums);
        int i = 0;
        while (i < nums.length - 1) {
            if (nums[i] == nums[i + 1]) {
                return true;
            }
            i++;
        }
        return false;
    }

    /**
     * 存在重复元素，且两个重复元素的索引最大值为k
     *
     * @param nums
     * @param k
     * @return
     */
    public static boolean containsNearbyDuplicate(int[] nums, int k) {
        if (nums.length <= 1) {
            return false;
        }
        //双指针法
        int i = 0;
        while (i < nums.length - 1) {
            int j = i + 1;
            while (j < nums.length) {
                if (nums[i] == nums[j] && j - i <= k) {
                    return true;
                } else if (j - i > k) {
                    break;
                }
                j++;
            }
            i++;
        }
        return false;
    }

    /**
     * 找到序列中缺失的数据
     *
     * @param nums
     * @return
     */
    public int missingNumber(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int total = 0;
        for (int i = 0; i < nums.length + 1; i++) {
            total += i;
        }
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
        }
        return total - sum;
    }

    /**
     * 三数最大乘积
     *
     * @param nums
     * @return
     */
    public int maximumProduct(int[] nums) {
        if (nums.length < 3) {
            return 0;
        }
        if (nums.length == 3) {
            return nums[0] * nums[1] * nums[2];
        }
        Arrays.sort(nums);
        int n = nums.length;
        int a = nums[n - 1] * nums[n - 2] * nums[n - 3];
        int b = nums[n - 1] * nums[0] * nums[1];
        return Math.max(a, b);
    }

    /**
     * 二进制连续1的最大个数
     *
     * @param nums
     * @return
     */
    public int findMaxConsecutiveOnes(int[] nums) {
        int rsp = 0;
        if (nums == null || nums.length == 0) {
            return rsp;
        }
        int i = 0;
        int rspTemp = 0;
        while (i < nums.length) {
            if (nums[i] == 1) {
                rspTemp++;
            }
            if (nums[i] == 0 || i == nums.length - 1) {
                rsp = Math.max(rsp, rspTemp);
                rspTemp = 0;
            }
            i++;
        }
        return rsp;
    }

    /**
     * 子数组最大平均数
     *
     * @param nums
     * @param k
     * @return
     */
    public static double findMaxAverage(int[] nums, int k) {
        if (nums == null || nums.length == 0 || nums.length < k) {
            return 0;
        }
        int sum = 0;
        for (int i = 0; i < nums.length - k + 1; i++) {
            int sumTemp = 0;
            for (int j = i; j < i + k; j++) {
                sumTemp += nums[j];
            }
            sum = Math.max(sum, sumTemp);
        }
        return (double) sum / k;
    }

    /**
     * k-diff数对
     *
     * @param nums
     * @param k
     * @return
     */
    public int findPairs(int[] nums, int k) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int rsp = 0;
        Arrays.sort(nums);
        int i = 0;
        while (i < nums.length - 1) {
            int j = i + 1;
            while (j < nums.length) {
                if (nums[j] - nums[i] == k) {
                    rsp++;
                    while (j + 1 < nums.length && nums[j] == nums[j + 1]) {
                        j++;
                    }
                }
                j++;
            }
            while (i + 1 < nums.length && nums[i] == nums[i + 1]) {
                i++;
            }
            i++;
        }
        return rsp;
    }

    /**
     * 数组拆分
     *
     * @param nums
     * @return
     */
    public int arrayPairSum(int[] nums) {
        //搭配的原则是：尽量大的跟大的搭配
        if (nums == null || nums.length == 0) {
            return 0;
        }
        Arrays.sort(nums);
        int rsp = 0;
        for (int i = 0; i < nums.length; i += 2) {
            rsp += Math.min(nums[i], nums[i + 1]);
        }
        return rsp;
    }

    //判断是否为回文链表
    public static boolean isPalindrome(ListNode head) {
        //方法1 数组法
        if (head == null) {
            return true;
        }
//        List<Integer> list = new ArrayList<>();
//        while (head != null) {
//            list.add(head.val);
//            head = head.next;
//        }
//        int i = 0, j = list.size() - 1;
//        while (i < j) {
//            if (!list.get(i).equals(list.get(j))) {
//                return false;
//            }
//            i++;
//            j--;
//        }
//        return true;

        //方法2 找到中间点 反转链表
        int n = 0;
        ListNode start = head;
        while (start != null) {
            n++;
            start = start.next;
        }
        n = n / 2;
        ListNode midNode = head;
        while (n > 0) {
            midNode = midNode.next;
            n--;
        }
        //reverse MidNode
        ListNode pre = null;
        ListNode cur = midNode;
        while (cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        while (head != null && pre != null) {
            if (head.val != pre.val) {
                return false;
            }
            head = head.next;
            pre = pre.next;
        }
        return true;
    }

    /**
     * 反转链表
     *
     * @param head
     * @return
     */
    public static ListNode reverseList(ListNode head) {
        //数组法
        // if(head==null){
        //     return head;
        // }
        // List<Integer>list=new ArrayList<Integer>();
        // while(head!=null){
        //     list.add(head.val);
        //     head=head.next;
        // }
        // ListNode dummy=new ListNode(0);
        // ListNode rsp=dummy;
        // for(int i=list.size()-1;i>=0;i--){
        //     dummy.next=new ListNode(list.get(i));
        //     dummy=dummy.next;
        // }
        // return rsp.next;
        //换一种思路
        ListNode pre = null;
        ListNode cur = head;
        while (cur != null) {
            ListNode nextTemp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nextTemp;
        }
        return pre;
    }
}
